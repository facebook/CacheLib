"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[5964],{3905:function(e,t,r){r.r(t),r.d(t,{MDXContext:function(){return u},MDXProvider:function(){return d},mdx:function(){return f},useMDXComponents:function(){return p},withMDXComponents:function(){return l}});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},i.apply(this,arguments)}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var u=n.createContext({}),l=function(e){return function(t){var r=p(t.components);return n.createElement(e,i({},t,{components:r}))}},p=function(e){var t=n.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):c(c({},t),e)),r},d=function(e){var t=p(e.components);return n.createElement(u.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),l=p(r),d=a,h=l["".concat(o,".").concat(d)]||l[d]||b[d]||i;return r?n.createElement(h,c(c({ref:t},u),{},{components:r})):n.createElement(h,c({ref:t},u))}));function f(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var u=2;u<i;u++)o[u]=r[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},8827:function(e,t,r){r.r(t),r.d(t,{assets:function(){return l},contentTitle:function(){return s},default:function(){return b},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return p}});var n=r(83117),a=r(80102),i=(r(67294),r(3905)),o=["components"],c={id:"About_CacheLib",title:"About CacheLib"},s="About CacheLib",u={unversionedId:"Cache_Library_User_Guides/About_CacheLib",id:"Cache_Library_User_Guides/About_CacheLib",title:"About CacheLib",description:"CacheLib is a C++ library for accessing and managing cache data. It is a thread-safe API that enables developers to build and customize scalable, concurrent caches. It is targeted at applications that dedicate gigabytes of memory to cache information.",source:"@site/docs/Cache_Library_User_Guides/About_CacheLib.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/About_CacheLib",permalink:"/docs/Cache_Library_User_Guides/About_CacheLib",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/About_CacheLib.md",tags:[],version:"current",frontMatter:{id:"About_CacheLib",title:"About CacheLib"},sidebar:"userguideSidebar",previous:{title:"CacheLib user guide",permalink:"/docs/"},next:{title:"Terms",permalink:"/docs/Cache_Library_User_Guides/terms"}},l={},p=[],d={toc:p};function b(e){var t=e.components,c=(0,a.Z)(e,o);return(0,i.mdx)("wrapper",(0,n.Z)({},d,c,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"about-cachelib"},"About CacheLib"),(0,i.mdx)("p",null,"CacheLib is a C++ library for accessing and managing cache data. It is a thread-safe API that enables developers to build and customize scalable, concurrent caches. It is targeted at applications that dedicate gigabytes of memory to cache information."),(0,i.mdx)("p",null,"To enable this, CacheLib provides a  simple find, insert, and remove APIs for applications to manage Items (key-value pairs) in the cache. CacheLib comes with several caching heuristics to manage evictions when the cache is full.  CacheLib is optimized for both DRAM and NVM caches through Hybrid cache, and empowers applications to achieve large cache capacities for the same or relatively lower cost. When enabled, Items evicted from DRAM will be inserted into NVM  and Items on NVM will be inserted back to DRAM cache upon lookup, and all of these transitions are transparent to users."),(0,i.mdx)("p",null,"CacheLib supports persisting cache data across application process restarts, and enables application developers to restart or update their binary without losing the cache data."),(0,i.mdx)("p",null,"CacheLib is, by default, highly optimized to maximize the system performance, and also provides variety of advanced configuration options for further tuning."),(0,i.mdx)("p",null,(0,i.mdx)("img",{src:r(99520).Z,width:"1725",height:"1125"})))}b.isMDXComponent=!0},99520:function(e,t,r){t.Z=r.p+"assets/images/cachelib_overview-8aef87842dc23f3bacd74ec6cd5cdc26.png"}}]);