"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[5159],{15680:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>m,MDXProvider:()=>d,mdx:()=>f,useMDXComponents:()=>p,withMDXComponents:()=>l});var a=n(96540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var m=a.createContext({}),l=function(e){return function(t){var n=p(t.components);return a.createElement(e,i({},t,{components:n}))}},p=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(m.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,m=c(e,["components","mdxType","originalType","parentName"]),l=p(n),d=r,u=l["".concat(o,".").concat(d)]||l[d]||h[d]||i;return n?a.createElement(u,s(s({ref:t},m),{},{components:n})):a.createElement(u,s({ref:t},m))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var m=2;m<i;m++)o[m]=n[m];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},85434:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>m,toc:()=>p});var a=n(9668),r=n(21367),i=(n(96540),n(15680)),o=["components"],s={id:"terms",title:"Terms"},c=void 0,m={unversionedId:"Cache_Library_User_Guides/terms",id:"Cache_Library_User_Guides/terms",title:"Terms",description:"Item",source:"@site/docs/Cache_Library_User_Guides/terms.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/terms",permalink:"/docs/Cache_Library_User_Guides/terms",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/terms.md",tags:[],version:"current",frontMatter:{id:"terms",title:"Terms"},sidebar:"userguideSidebar",previous:{title:"About CacheLib",permalink:"/docs/Cache_Library_User_Guides/About_CacheLib"},next:{title:"Set up a simple dram cache",permalink:"/docs/Cache_Library_User_Guides/Set_up_a_simple_cache"}},l={},p=[],d={toc:p};function h(e){var t=e.components,n=(0,r.A)(e,o);return(0,i.mdx)("wrapper",(0,a.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Item"),"\nAn item is an object stored in cache. In addition to storing the payload (the\nactual data), it also stores metadata: intrusive hooks, reference count, flags,\ncreation time, and expiration time. An item is assigned a ",(0,i.mdx)("inlineCode",{parentName:"p"},"key")," that\ncachelib API uses to find the item. For more information, see\n",(0,i.mdx)("a",{parentName:"p",href:"Item_and_Handle"},"Item and Handle"),"."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"WriteHandle and ReadHandle"),"\nA WriteHandle(fka ItemHandle) is similar to a ",(0,i.mdx)("inlineCode",{parentName:"p"},"std::shared_ptr<Item>"),". It is used to\naccess a mutable item.\nA ReadHandle is similar to a ",(0,i.mdx)("inlineCode",{parentName:"p"},"std::shared_ptr<const Item>"),". It is used to access a read-only item.\nFor more information, see ",(0,i.mdx)("a",{parentName:"p",href:"Item_and_Handle"},"Item and Handle"),"."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Chained item"),"\nAn item has fixed memory size in cache. To grow the item, add chained items to it. A chained item doesn't have a key; thus you must use its parent item to access it. For more information, see ",(0,i.mdx)("a",{parentName:"p",href:"chained_items"},"Chained Items"),"."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Key"),"\nA key is a byte-array identifier assigned to a cached item. Cachelib uses it to find the item. A key can be a string or a POD (memcpy-safe)."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Allocation size"),"\nThis is the size (in number of bytes) of all the content associated with an item: header, key, and value."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Allocation class"),"\nEach allocation class represents a specific allocation size. Items, within the same memory pool, of the same allocation size come from the same allocation class. Each allocation class can take a number of slabs and give out allocations from the slabs (like a classic slab allocator)."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Slab"),"\nA slab is a logical unit of a fixed chunk of DRAM memory; it is hardcoded to 4 MB currently. Cachelib separates the whole cacheable memory into a number of slabs. Memory allocations for ",(0,i.mdx)("inlineCode",{parentName:"p"},"Item")," is carved out of slabs."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Pool"),"\nA pool is a block of memory of a specific size in a cache. Pools enable you to separate different objects in the cache; that is, objects in one pool are isolated from objects in the other. In addition, they improve hit ratio. For more information, see ",(0,i.mdx)("a",{parentName:"p",href:"Partition_cache_into_pools"},"Partitioning cache into pools"),"."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Pool rebalance"),"\nWhen you cache objects of variable sizes, over time, the cache memory is fragmented. To fix this, enable pool reblancing. For more information, see ",(0,i.mdx)("a",{parentName:"p",href:"pool_rebalance_strategy"},"Pool Rebalance Strategy"),"."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Eviction"),"\nEviction refers an item exiting from cache because the cache storage is full\nor because the item is no longer relevant to be cached. Evictions are\ntriggerred internally by CacheLib and are controlled by either the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Eviction\nPolicy")," (see ",(0,i.mdx)("a",{parentName:"p",href:"eviction_policy"},"Eviction Policy"),") or the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Admission Policy"),"  of\nthe cache depending on the setup. An ",(0,i.mdx)("inlineCode",{parentName:"p"},"Item")," can also be evicted from\nthe cache in response to certain internal events like Pool rebalancing."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Removal"),"\nRemoval refers to an item exiting the cache when the ",(0,i.mdx)("inlineCode",{parentName:"p"},"remove")," api is invoked."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Expiry"),"\nExpiry refers to an item exiting the cache when its time to live (TTL) is\nexhausted. By default, items don't expire unless a TTL is explicitly set."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Item lifetime"),"\nTime in cache since the creation of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Item")," up until eviction of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"Item")," from the cache."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Eviction Age"),"\nTime in cache for an Item from its last access time up to its eviction."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"HybridCache"),"\nHybridCache is non-volatile memory (NVM) cache (flash). When you use HybridCache, items allocated in cache can live on NVM or DRAM. For more information, see ",(0,i.mdx)("a",{parentName:"p",href:"HybridCache"},"HybridCache"),"."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Compact cache"),"\nA compact cache is used to store small key-value data, usually less than tens of bytes per entry. The size of the key must be fixed at compile time, whereas the size of the value can be fixed, variable, or empty. For more information, see ",(0,i.mdx)("a",{parentName:"p",href:"compact_cache"},"Compact Cache"),"."))}h.isMDXComponent=!0}}]);