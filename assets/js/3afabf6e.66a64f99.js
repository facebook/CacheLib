"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[6499],{15680:(e,a,n)=>{n.r(a),n.d(a,{MDXContext:()=>l,MDXProvider:()=>p,mdx:()=>f,useMDXComponents:()=>d,withMDXComponents:()=>m});var t=n(96540);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(){return i=Object.assign||function(e){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},i.apply(this,arguments)}function o(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function c(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?o(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function s(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=t.createContext({}),m=function(e){return function(a){var n=d(a.components);return t.createElement(e,i({},a,{components:n}))}},d=function(e){var a=t.useContext(l),n=a;return e&&(n="function"==typeof e?e(a):c(c({},a),e)),n},p=function(e){var a=d(e.components);return t.createElement(l.Provider,{value:a},e.children)},h={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},u=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=d(n),p=r,u=m["".concat(o,".").concat(p)]||m[p]||h[p]||i;return n?t.createElement(u,c(c({ref:a},l),{},{components:n})):t.createElement(u,c({ref:a},l))}));function f(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var c={};for(var s in a)hasOwnProperty.call(a,s)&&(c[s]=a[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var l=2;l<i;l++)o[l]=n[l];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}u.displayName="MDXCreateElement"},78143:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>m,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>l,toc:()=>d});var t=n(9668),r=n(21367),i=(n(96540),n(15680)),o=["components"],c={id:"Cachebench_FB_HW_eval",title:"Evaluating SSD hardware for Facebook workloads"},s=void 0,l={unversionedId:"Cache_Library_User_Guides/Cachebench_FB_HW_eval",id:"Cache_Library_User_Guides/Cachebench_FB_HW_eval",title:"Evaluating SSD hardware for Facebook workloads",description:"CacheBench is a cache benchmark tool used to stress the storage and",source:"@site/docs/Cache_Library_User_Guides/Cachebench_FB_HW_eval.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/Cachebench_FB_HW_eval",permalink:"/docs/Cache_Library_User_Guides/Cachebench_FB_HW_eval",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/Cachebench_FB_HW_eval.md",tags:[],version:"current",frontMatter:{id:"Cachebench_FB_HW_eval",title:"Evaluating SSD hardware for Facebook workloads"},sidebar:"cachebenchSideBar",previous:{title:"Contributing to Cachebench",permalink:"/docs/Cache_Library_User_Guides/Developing_for_Cachebench"}},m={},d=[{value:"System requirements",id:"system-requirements",level:2},{value:"Set up the SSD devices",id:"set-up-the-ssd-devices",level:2},{value:"Installing cachebench",id:"installing-cachebench",level:2},{value:"Running the benchmark for SSD perf testing",id:"running-the-benchmark-for-ssd-perf-testing",level:2},{value:"Tuning the workload and cache parameters",id:"tuning-the-workload-and-cache-parameters",level:3},{value:"Running cachebench with the trace workload",id:"running-cachebench-with-the-trace-workload",level:2},{value:"List of traces",id:"list-of-traces",level:3},{value:"Resource Scaling or Trace Amplifcation",id:"resource-scaling-or-trace-amplifcation",level:3},{value:"Getting the Results",id:"getting-the-results",level:2},{value:"Plotting latency stats",id:"plotting-latency-stats",level:2}],p={toc:d};function h(e){var a=e.components,n=(0,r.A)(e,o);return(0,i.mdx)("wrapper",(0,t.A)({},p,n,{components:a,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"CacheBench")," is a cache benchmark tool used to stress the storage and\nmemory subsystem in a comparable way that they are stressed\nin production workloads. This doc describes how Facebook leverages CacheBench\nto validate SSD performance."),(0,i.mdx)("h2",{id:"system-requirements"},"System requirements"),(0,i.mdx)("p",null,"To run CacheBench, first ensure that the machine has\nsufficient free memory (50+GB) and SSD capacity (1TB)."),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Memory: 64GB or more"),(0,i.mdx)("li",{parentName:"ul"},"SSD Capacity: 100GB or more available capacity"),(0,i.mdx)("li",{parentName:"ul"},"Internet connection capable of accessing github.com and installing packages")),(0,i.mdx)("h2",{id:"set-up-the-ssd-devices"},"Set up the SSD devices"),(0,i.mdx)("p",null,"To gather SSD performance metrics, the SSD must be setup first. Cachebench (and CacheLib) supports using various types of devices for NVM cache including a raw block device or a regular file. When one wants to use multiple SSDs as NVM cache, the CacheLib also provides a native support for RAI",(0,i.mdx)("a",{parentName:"p",href:"https://internalfb.com/D0"},"D0")," (i.e., striping)."),(0,i.mdx)("p",null,"Optionally, as an example, an user can setup and use md devices as follows. In this example, the md device is created from two ssd devices to be used as a raw block device in CacheBench."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"mdadm --create /dev/md0 --force --raid-devices=2 --level=0 --chunk=256 /dev/nvme1n1 /dev/nvme2n1\n")),(0,i.mdx)("h2",{id:"installing-cachebench"},"Installing cachebench"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"If you have not already, clone the cachelib repository from github.com:"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"git clone https://github.com/facebook/CacheLib.git\n"))),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"Build cachelib and ",(0,i.mdx)("inlineCode",{parentName:"p"},"cachebench"),":"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"cd CacheLib\n./contrib/build.sh -j\n")),(0,i.mdx)("p",{parentName:"li"},"Notes:"),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"It will take several minutes to build and install all dependencies."),(0,i.mdx)("li",{parentName:"ul"},"Remove ",(0,i.mdx)("inlineCode",{parentName:"li"},"-j")," flag to build using only a single CPU (build will take longer)"),(0,i.mdx)("li",{parentName:"ul"},"The script will automatically use ",(0,i.mdx)("inlineCode",{parentName:"li"},"sudo")," to install several OS packages (using ",(0,i.mdx)("inlineCode",{parentName:"li"},"apt"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"dnf"),", etc.)"),(0,i.mdx)("li",{parentName:"ul"},"The build script has been tested to work on stable Debian, Ubuntu, CentOS, RockyLinux.\nOther systems are possible but not officially supported."))),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"The resulting binaries and libraries will be in ",(0,i.mdx)("inlineCode",{parentName:"p"},"./opt/cachelib"),":"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"./opt/cachelib/bin/cachebench --help\n")),(0,i.mdx)("p",{parentName:"li"},"or"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"cd ./opt/cachelib/bin/\n./cachebench --help\n"))),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"Sample test configurations are provided in ",(0,i.mdx)("inlineCode",{parentName:"p"},"./opt/cachelib/test_configs/"),".\nExample:"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"cd ./opt/cachelib\n./bin/cachebench --json_test_config ./test_configs/simple_test.json\n")))),(0,i.mdx)("details",null,(0,i.mdx)("summary",null,"Expected Output of test run"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'$ cd ./opt/cachelib\n$ ./bin/cachebench --json_test_config ./test_configs/simple_test.json\n===JSON Config===\n// @nolint instantiates a small cache and runs a quick run of basic operations.\n{\n  "cache_config" : {\n    "cacheSizeMB" : 512,\n    "poolRebalanceIntervalSec" : 1,\n    "moveOnSlabRelease" : false,\n\n    "numPools" : 2,\n    "poolSizes" : [0.3, 0.7]\n  },\n  "test_config" : {\n\n      "numOps" : 100000,\n      "numThreads" : 32,\n      "numKeys" : 1000000,\n\n      "keySizeRange" : [1, 8, 64],\n      "keySizeRangeProbability" : [0.3, 0.7],\n\n      "valSizeRange" : [1, 32, 10240, 409200],\n      "valSizeRangeProbability" : [0.1, 0.2, 0.7],\n\n      "getRatio" : 0.15,\n      "setRatio" : 0.8,\n      "delRatio" : 0.05,\n      "keyPoolDistribution": [0.4, 0.6],\n      "opPoolDistribution" : [0.5, 0.5]\n    }\n}\n\nWelcome to OSS version of cachebench\nCreated 897,355 keys in 0.00 mins\nGenerating 1.60M sampled accesses\nGenerating 1.60M sampled accesses\nGenerated access patterns in 0.00 mins\nTotal 3.20M ops to be run\n12:07:12       0.00M ops completed\n== Test Results ==\n== Allocator Stats ==\nItems in RAM  : 96,995\nItems in NVM  : 0\nAlloc Attempts: 2,559,176 Success: 100.00%\nRAM Evictions : 2,163,672\nCache Gets    : 480,592\nHit Ratio     :  10.97%\nNVM Gets      :               0, Coalesced : 100.00%\nNVM Puts      :               0, Success   :   0.00%, Clean   : 100.00%, AbortsFromDel   :        0, AbortsFromGet   :        0\nNVM Evicts    :               0, Clean     : 100.00%, Unclean :       0, Double          :        0\nNVM Deletes   :               0 Skipped Deletes: 100.00%\nReleased 21 slabs\n  Moves     : attempts:          0, success: 100.00%\n  Evictions : attempts:      3,040, success:  99.57%\n\n== Throughput for  ==\nTotal Ops : 3.20 million\nTotal sets: 2,559,176\nget       :    49,453/s, success   :  10.97%\nset       :   263,344/s, success   : 100.00%\ndel       :    16,488/s, found     :  10.83%\n'))),(0,i.mdx)("ol",{start:5},(0,i.mdx)("li",{parentName:"ol"},"If fio is not installed, build it with:",(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"git clone https://github.com/axboe/fio.git\ncd fio\n./configure\nmake\nmake install\n")))),(0,i.mdx)("p",null,"See ",(0,i.mdx)("a",{parentName:"p",href:"/docs/installation"},"build and installation")," for further details."),(0,i.mdx)("h2",{id:"running-the-benchmark-for-ssd-perf-testing"},"Running the benchmark for SSD perf testing"),(0,i.mdx)("p",null,"Cachebench has three configs packaged for SSD validation. These are under ",(0,i.mdx)("inlineCode",{parentName:"p"},"test_configs/ssd_perf/<service-domain>"),'. Currently, we have "graph_cache_leader", "kvcache_reg", and "kvcache_wc" which represent three distinct cache workloads from Facebook. Below, we show how the benchmarks can be run for two of these workloads. It is important to trim the ssds between the runs to ensure any interference is avoided.'),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"Change to the path where you previously copied cachebench to.",(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"cd <your path>\n"))),(0,i.mdx)("li",{parentName:"ol"},"If ",(0,i.mdx)("inlineCode",{parentName:"li"},"/dev/md0")," is not being used, edit workload files appropiately.\nChange all instances of ",(0,i.mdx)("inlineCode",{parentName:"li"},"/dev/md0")," to raw path of data SSD(s):",(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"vi ./test_configs/ssd_perf/graph_cache_leader/config.json\nvi ./test_configs/ssd_perf/kvcache_l2_wc/config.json\n"))," See ",(0,i.mdx)("a",{parentName:"li",href:"Configuring_cachebench_parameters#storage-filedevicedirectory-path-info"},"configuring storage path"),"  for more details on how to configure the storage path."),(0,i.mdx)("li",{parentName:"ol"},"Before each benchmark run, fully trim the drive with fio:",(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"fio --name=trim --filename=/dev/md0 --rw=trim --bs=3G\n"))),(0,i.mdx)("li",{parentName:"ol"},"Execute social graph leader cache workload:",(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"./cachebench -json_test_config test_configs/ssd_perf/graph_cache_leader/config.json --progress_stats_file=/tmp/graph_cache_leader.log\n"))),(0,i.mdx)("li",{parentName:"ol"},"Fully trim the drive with fio again:",(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"fio --name=trim --filename=/dev/md0 --rw=trim --bs=3G\n"))),(0,i.mdx)("li",{parentName:"ol"},"Execute the ",(0,i.mdx)("inlineCode",{parentName:"li"},"kvcache")," workload:",(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"./cachebench -json_test_config test_configs/ssd_perf/kvcache_l2_wc/config.json \u2014progress_stats_file=/tmp/mc-l2-wc.log\n")))),(0,i.mdx)("h3",{id:"tuning-the-workload-and-cache-parameters"},"Tuning the workload and cache parameters"),(0,i.mdx)("p",null,"For a full list of options that can be configured, see ",(0,i.mdx)("a",{parentName:"p",href:"Configuring_cachebench_parameters"},"configuring cachebench")),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("strong",{parentName:"li"},"Target QPS")," - The target QPS (Query/Transactions Per Second) can be configured\nusing ",(0,i.mdx)("inlineCode",{parentName:"li"},"opRatePerSec")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"opRateBurstSize")," which controls the parameter of\ntoken-bucket"),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("strong",{parentName:"li"},"Duration of Replay")," - To run cachebench operation for longer,\nincrease the ",(0,i.mdx)("inlineCode",{parentName:"li"},"numOps")," appropriately in the config file."),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("strong",{parentName:"li"},"Device Info")," - Device info is configured in the config file\nusing the ",(0,i.mdx)("inlineCode",{parentName:"li"},"nvmCachePaths")," option.  If you would rather use a\nfilesystem based cache, pass the appropriate path through\n",(0,i.mdx)("inlineCode",{parentName:"li"},"nvmCachePaths"),".  The benchmark will create a single file\nunder that path corresponding to the configured ",(0,i.mdx)("inlineCode",{parentName:"li"},"nvmCacheSizeMB")),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("strong",{parentName:"li"},"Watching Progress")," -  While the benchmark runs, you can monitor the\nprogress so far. The interval for progress update can be configured\nusing the ",(0,i.mdx)("inlineCode",{parentName:"li"},"--progress")," and specifying a duration in seconds.\nIf ",(0,i.mdx)("inlineCode",{parentName:"li"},"--progress-stats-file")," is also specified, on every progress\ninterval, ",(0,i.mdx)("inlineCode",{parentName:"li"},"cachebench")," would log the internal stats to the specified file.")),(0,i.mdx)("h2",{id:"running-cachebench-with-the-trace-workload"},"Running cachebench with the trace workload"),(0,i.mdx)("p",null,"Meta is sharing anonymized traces captured from large scale production cache services. These traces are licensed under the same license as CacheLib. They are meant to help academic and industry researchers to optimize for our caching workloads. One can freely download it from our AWS ",(0,i.mdx)("a",{parentName:"p",href:"https://internalfb.com/S3"},"S3")," bucket and run the CacheBench to replay the trace with varying configuration as follows."),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"Install and setup the AWS CLI")),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"Download the tracedata"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"$ aws s3 ls --no-sign-request s3://cachelib-workload-sharing/pub/kvcache/202206/\n2023-02-09 13:37:50       1374 config_kvcache.json\n2023-02-09 13:38:58 4892102575 kvcache_traces_1.csv\n2023-02-09 13:38:58 4814294537 kvcache_traces_2.csv\n2023-02-09 13:38:58 4678364393 kvcache_traces_3.csv\n2023-02-09 13:38:58 4734675702 kvcache_traces_4.csv\n2023-02-09 13:38:58 4810857756 kvcache_traces_5.csv\n$ aws s3 cp --no-sign-request --recursive s3://cachelib-workload-sharing/pub/kvcache/202206/ ./\n"))),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"Modify the test config as needed (see following section)"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"$ vi ./config_kvcache.json\n"))),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"Execute the trace workload"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"./cachebench -json_test_config ./config_kvcache.json \u2014progress_stats_file=/tmp/kvcache-trace.log\n")))),(0,i.mdx)("h3",{id:"list-of-traces"},"List of traces"),(0,i.mdx)("p",null,"The list of traces uploaded are as follows"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"kvcache/202206")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"Those are traces captured for 5 consecutive days from a Meta's key-value cache cluster consisting of 500 hosts"),(0,i.mdx)("li",{parentName:"ul"},"Each host uses (roughly) 42 GB of DRAM and 930 GB of SSD for caching"),(0,i.mdx)("li",{parentName:"ul"},"The traffic factor is 1/100"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"kvcache/202401")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"Those are traces captured for 5 consecutive days from a Meta's key-value cache cluster consisting of 8000 hosts"),(0,i.mdx)("li",{parentName:"ul"},"Each host uses (roughly) 42 GB of DRAM and 930 GB of SSD for caching"),(0,i.mdx)("li",{parentName:"ul"},"The traffic factor is 1/125"),(0,i.mdx)("li",{parentName:"ul"},"This trace provides usecase and sub-usecase columns additionally; usecase identifies the tenant (i.e., application using distributed key-value cache). The sub-usecase is meant to further categorize the different traffics from the same usecase, but should be considered neither complete nor accurate"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"cdn/202303/")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"Those are traces captured from Meta's 3 selected CDN cache clusters (named nha, prn, eag) respectively for 7 days on Mar 2023"),(0,i.mdx)("li",{parentName:"ul"},"Each cluster consists of 1000's of hosts"),(0,i.mdx)("li",{parentName:"ul"},"Each host uses (roughly) 40 GB of DRAM and 1.8TB of SSD for caching"),(0,i.mdx)("li",{parentName:"ul"},"Traffic factor and scaled cache sizes are:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"nha: 1/6.37, DRAM 6006 MB, NVM 272314 MB"),(0,i.mdx)("li",{parentName:"ul"},"prn: 1/4.58, DRAM 8357 MB, NVM 375956 MB"),(0,i.mdx)("li",{parentName:"ul"},"eag: 1/13.4, DRAM 2857 MB, NVM 129619 MB"))))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"storage/202312")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},"Those are traces captured for 5 consecutive days from a Meta's block storage cluster consisting of 3000 hosts at the sampling ratio of 1/4000"),(0,i.mdx)("li",{parentName:"ul"},"Each host uses (roughly) 10 GB of DRAM and 380 GB of SSD for caching"),(0,i.mdx)("li",{parentName:"ul"},"The traffic factor is ~1")))),(0,i.mdx)("h3",{id:"resource-scaling-or-trace-amplifcation"},"Resource Scaling or Trace Amplifcation"),(0,i.mdx)("p",null,"The trace is captured at a certain sampling ratio and the traffic factor is defined as the ratio of the captured traffic normalized to those received from a single host in the production. For example, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"kvcache/202206")," is sampled at the ratio of 1/50'000 from 500 hosts, meaning the traffic factor is 1/100. This means that the trace data contains the samples amount to 1/100 of those handled by each host on average. So, in order to get the similar results from the cachebench simulation, either the cache resource or the trace data needs to be scaled accordingly."),(0,i.mdx)("p",null,"The resource scaling is useful when the required resources (e.g., NVM cache 1TB) are not available in the simulation system or when one is interested in iterating fast with sacrificing accuracy of some metrics. The resource scaling can be done by modifying the ",(0,i.mdx)("inlineCode",{parentName:"p"},"cache_config")," in the cachebench test config."),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("strong",{parentName:"li"},"cacheSizeMB")," - This controls the DRAM cache size"),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("strong",{parentName:"li"},"nvmCacheSizeMB")," - This controls the size of NVM cache")),(0,i.mdx)("p",null,"Amplifying the trace data is useful to achieve the highest accuracy of the simulation. The cachebench supports amplifying the trace data by amplifying the key population; specifically, when cachebench replays the trace entry, it duplicates each trace entry by specified number of times (i.e., amplification factor) by appending suffixes ranging from ",(0,i.mdx)("inlineCode",{parentName:"p"},"0")," to ",(0,i.mdx)("inlineCode",{parentName:"p"},"k - 1")," to the key for the amplification factor of ",(0,i.mdx)("inlineCode",{parentName:"p"},"k"),". The trace amplifcation factor can be specified in ",(0,i.mdx)("inlineCode",{parentName:"p"},"test_config")," section as part of ",(0,i.mdx)("inlineCode",{parentName:"p"},"replayGeneratorConfig"),"."),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("strong",{parentName:"li"},"ampFactor")," - specifies the amplification factor for replay generator")),(0,i.mdx)("h2",{id:"getting-the-results"},"Getting the Results"),(0,i.mdx)("p",null,"View results summary through the log file:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-sh"},"tail -n 50 /tmp/graph_cache_leader.log\ntail -n 50 /tmp/mc-l2-wc.log\n")),(0,i.mdx)("h2",{id:"plotting-latency-stats"},"Plotting latency stats"),(0,i.mdx)("p",null,"The stats output can be parsed to plot SSD latency information over time. To\ndo this, first ensure ",(0,i.mdx)("inlineCode",{parentName:"p"},"gnuplot")," is installed. For example, on CentOs:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-shell"},"yum install gnuplot\n")),(0,i.mdx)("p",null,"Then run this command to get the latency stats:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-shell"},"./vizualize/extract_latency.sh /tmp/graph_cache_leader.log\n./vizualize/extract_latency.sh /tmp/mc-l2-wc.log\n")),(0,i.mdx)("p",null,"This should produce a tsv file for read latency, a tsv file for write latency, and the corresponding ",(0,i.mdx)("inlineCode",{parentName:"p"},"png")," files that have the graphs plotted."))}h.isMDXComponent=!0}}]);