"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[4055],{3905:function(e,t,a){a.r(t),a.d(t,{MDXContext:function(){return m},MDXProvider:function(){return p},mdx:function(){return b},useMDXComponents:function(){return s},withMDXComponents:function(){return d}});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},r.apply(this,arguments)}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var m=n.createContext({}),d=function(e){return function(t){var a=s(t.components);return n.createElement(e,r({},t,{components:a}))}},s=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=s(e.components);return n.createElement(m.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=c(e,["components","mdxType","originalType","parentName"]),d=s(a),p=i,h=d["".concat(l,".").concat(p)]||d[p]||u[p]||r;return a?n.createElement(h,o(o({ref:t},m),{},{components:a})):n.createElement(h,o({ref:t},m))}));function b(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var m=2;m<r;m++)l[m]=a[m];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},27863:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return c},default:function(){return u},frontMatter:function(){return o},metadata:function(){return m},toc:function(){return s}});var n=a(83117),i=a(80102),r=(a(67294),a(3905)),l=["components"],o={id:"Object_Cache_User_Guide",title:"CacheLib Object Cache User Guide"},c=void 0,m={unversionedId:"facebook/Object_Cache/Object_Cache_User_Guide",id:"facebook/Object_Cache/Object_Cache_User_Guide",title:"CacheLib Object Cache User Guide",description:"Object-Cache enables users to cache C++ objects natively in CacheLib.",source:"@site/docs/facebook/Object_Cache/object_cache_user_guide.md",sourceDirName:"facebook/Object_Cache",slug:"/facebook/Object_Cache/Object_Cache_User_Guide",permalink:"/docs/facebook/Object_Cache/Object_Cache_User_Guide",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/facebook/Object_Cache/object_cache_user_guide.md",tags:[],version:"current",frontMatter:{id:"Object_Cache_User_Guide",title:"CacheLib Object Cache User Guide"}},d={},s=[{value:"Set up object-cache",id:"set-up-object-cache",level:2},{value:"Create a simple object-cache",id:"create-a-simple-object-cache",level:3},{value:"Configuration",id:"configuration",level:4},{value:"Create a &quot;size-aware&quot; object-cache",id:"create-a-size-aware-object-cache",level:3},{value:"Configuration",id:"configuration-1",level:4},{value:"How to set l1EntriesLimit",id:"how-to-set-l1entrieslimit",level:4},{value:"How to calculate object size",id:"how-to-calculate-object-size",level:4},{value:"How is object size tracked",id:"how-is-object-size-tracked",level:4},{value:"What is size controller",id:"what-is-size-controller",level:4},{value:"Add monitoring",id:"add-monitoring",level:3},{value:"Use object-cache",id:"use-object-cache",level:2},{value:"Add objects",id:"add-objects",level:3},{value:"Get objects",id:"get-objects",level:3},{value:"Mutate objects",id:"mutate-objects",level:3},{value:"Remove objects",id:"remove-objects",level:3},{value:"Monitor object-cache",id:"monitor-object-cache",level:2},{value:"TTL (Time To Live)",id:"ttl-time-to-live",level:2},{value:"Set TTL",id:"set-ttl",level:3},{value:"Get TTL",id:"get-ttl",level:3},{value:"Update TTL",id:"update-ttl",level:3},{value:"Cache Persistence",id:"cache-persistence",level:2},{value:"Configure cache persistence",id:"configure-cache-persistence",level:3},{value:"Use cache persistence",id:"use-cache-persistence",level:3}],p={toc:s};function u(e){var t=e.components,a=(0,i.Z)(e,l);return(0,r.mdx)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"Object-Cache enables users to cache C++ objects natively in CacheLib."),(0,r.mdx)("p",null,"Not sure whether you should use object-cache? Check the ",(0,r.mdx)("a",{parentName:"p",href:"Object_Cache_Decision_Guide"},"object-cache decision guide"),"."),(0,r.mdx)("h2",{id:"set-up-object-cache"},"Set up object-cache"),(0,r.mdx)("h3",{id:"create-a-simple-object-cache"},"Create a simple object-cache"),(0,r.mdx)("p",null,"The simplest object-cache is limited by the ",(0,r.mdx)("strong",{parentName:"p"},"number of objects"),", i.e. an eviction will be triggered when the total object number reaches certain limit; the limit needs to be configured by the user as ",(0,r.mdx)("inlineCode",{parentName:"p"},"l1EntriesLimit"),"."),(0,r.mdx)("p",null,"You are good to use this option if"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"your system is able to track the number of objects and provide that limit, and"),(0,r.mdx)("li",{parentName:"ul"},"there is no memory risk (e.g. memory regression/OOM caused by variations or gradual increase in object size)")),(0,r.mdx)("p",null,"Otherwise, you may need to ",(0,r.mdx)("a",{parentName:"p",href:"#create-a-size-aware-object-cache"},'create a "size-aware" object-cache'),"."),(0,r.mdx)("h4",{id:"configuration"},"Configuration"),(0,r.mdx)("p",null,"You can set up a simple object-cache by configuring the following settings in ",(0,r.mdx)("inlineCode",{parentName:"p"},"ObjectCacheConfig"),":"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"l1EntriesLimit"),": The object number limit for object-cache to hold. Above this many entries, object-cache will start evicting."),(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"cacheName"),": The name of the cache."),(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"itemDestructor"),": The callback that will be triggered when the object leaves the cache. Users must set this to explicitly delete the objects; otherwise, there will be memory leak.")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"// store a single type of objects\nconfig.setItemDestructor(\n      [&](ObjectCacheDestructorData data) {\n        data.deleteObject<Foo>();\n});\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"// store multiple types of objects\n// One way is to encode the type in the key.\nenum class user_defined_ObjectType { Foo1, Foo2, Foo3 };\n\nconfig.setItemDestructor([&](ObjectCacheDestructorData data) {\n     switch (user_defined_getType(data.key)) {\n       case user_defined_ObjectType::Foo1:\n         data.deleteObject<Foo1>();\n         break;\n       case user_defined_ObjectType::Foo2:\n         data.deleteObject<Foo2>();\n         break;\n       case user_defined_ObjectType::Foo3:\n         data.deleteObject<Foo3>();\n         break;\n       ...\n     }\n });\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Suggested"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"maxKeySizeBytes"),": The maximum size of the key to be inserted. It cannot exceed 255 bytes. Default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"255"),". Since we also use this size to decide the allocation size of object-cache, we suggest you set a reasonble value to avoid wasting space.")),(0,r.mdx)("details",null,(0,r.mdx)("summary",null," Max Key Size : Allocation Size Mapping Table  "),(0,r.mdx)("table",null,(0,r.mdx)("thead",{parentName:"table"},(0,r.mdx)("tr",{parentName:"thead"},(0,r.mdx)("th",{parentName:"tr",align:null},"Max Key Size Bytes"),(0,r.mdx)("th",{parentName:"tr",align:null},"Allocation Size Bytes"))),(0,r.mdx)("tbody",{parentName:"table"},(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[8, 16]"),(0,r.mdx)("td",{parentName:"tr",align:null},"64")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[17, 24]"),(0,r.mdx)("td",{parentName:"tr",align:null},"72")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[25, 32]"),(0,r.mdx)("td",{parentName:"tr",align:null},"80")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[33, 40]"),(0,r.mdx)("td",{parentName:"tr",align:null},"88")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[41, 48]"),(0,r.mdx)("td",{parentName:"tr",align:null},"96")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[49, 56]"),(0,r.mdx)("td",{parentName:"tr",align:null},"104")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[57, 64]"),(0,r.mdx)("td",{parentName:"tr",align:null},"112")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[65, 72]"),(0,r.mdx)("td",{parentName:"tr",align:null},"120")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[73, 80]"),(0,r.mdx)("td",{parentName:"tr",align:null},"128")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[81, 88]"),(0,r.mdx)("td",{parentName:"tr",align:null},"136")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[89, 96]"),(0,r.mdx)("td",{parentName:"tr",align:null},"144")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[97, 104]"),(0,r.mdx)("td",{parentName:"tr",align:null},"152")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[105, 112]"),(0,r.mdx)("td",{parentName:"tr",align:null},"160")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[113, 120]"),(0,r.mdx)("td",{parentName:"tr",align:null},"168")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[121, 128]"),(0,r.mdx)("td",{parentName:"tr",align:null},"176")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[129, 136]"),(0,r.mdx)("td",{parentName:"tr",align:null},"184")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[137, 144]"),(0,r.mdx)("td",{parentName:"tr",align:null},"192")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[145, 152]"),(0,r.mdx)("td",{parentName:"tr",align:null},"200")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[153, 160]"),(0,r.mdx)("td",{parentName:"tr",align:null},"208")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[161, 168]"),(0,r.mdx)("td",{parentName:"tr",align:null},"216")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[169, 176]"),(0,r.mdx)("td",{parentName:"tr",align:null},"224")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[177, 184]"),(0,r.mdx)("td",{parentName:"tr",align:null},"232")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[185, 192]"),(0,r.mdx)("td",{parentName:"tr",align:null},"240")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[193, 200]"),(0,r.mdx)("td",{parentName:"tr",align:null},"248")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[201, 208]"),(0,r.mdx)("td",{parentName:"tr",align:null},"256")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[209, 216]"),(0,r.mdx)("td",{parentName:"tr",align:null},"264")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[217, 224]"),(0,r.mdx)("td",{parentName:"tr",align:null},"272")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[225, 232]"),(0,r.mdx)("td",{parentName:"tr",align:null},"280")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[233, 240]"),(0,r.mdx)("td",{parentName:"tr",align:null},"288")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[241, 248]"),(0,r.mdx)("td",{parentName:"tr",align:null},"296")),(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:null},"[249, 255]"),(0,r.mdx)("td",{parentName:"tr",align:null},"304"))))),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"accessConfig"),": Config to tune lookup performance. There are two important parameters:",(0,r.mdx)("inlineCode",{parentName:"li"},"l1HashTablePower")," and ",(0,r.mdx)("inlineCode",{parentName:"li"},"l1LockPower"),". Check out ",(0,r.mdx)("a",{parentName:"li",href:"../../Cache_Library_User_Guides/Configure_HashTable"},"hashtable bucket configuration")," to select a good value:",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"l1HashTablePower"),": This controls how many buckets are present in object-cache's hashtable. Default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"10"),"."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"l1LockPower"),": This controls how many locks are present in object-cache's hashtable. Default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"10"),"."))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"l1NumShards"),": Number of shards to improve insert/remove concurrency. Default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"1"),"."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"l1ShardName"),": Name of the shards. If not set, we will use the default name ",(0,r.mdx)("inlineCode",{parentName:"li"},"pool"),"."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"evictionPolicyConfig"),": Config of the eviction policy. Object-Cache offers the same set of ",(0,r.mdx)("a",{parentName:"li",href:"/docs/Cache_Library_User_Guides/eviction_policy"},"eviction policies")," as the regular cachelib. Typically, you can just leave the config as default. If in some cases, the default one does not work, you are also allowed to modify the settings, e.g.")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"// adopting LRU eviction policy\nusing ObjectCache = cachelib::objcache2::ObjectCache<cachelib::LruAllocator>;\ntypename ObjectCache::EvictionPolicyConfig evictionPolicyConfig;\n// By default, updateOnRead is true and updateOnWrite is false.\nevictionPolicyConfig.updateOnRead = false;\nevictionPolicyConfig.updateOnWrite = true;\n\nObjectCache::Config config;\n...\nconfig.setEvictionPolicyConfig(std::move(evictionPolicyConfig));\n")),(0,r.mdx)("p",null,"Here is an example to configure a simple object-cache:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/object_cache/ObjectCache.h"\n\nusing ObjectCache = cachelib::objcache2::ObjectCache<cachelib::LruAllocator>;\nstd::unique_ptr<ObjectCache> objCache;\n\nstruct Foo {\n ...\n};\n\nvoid init() {\n    ObjectCache::Config config;\n    config.setCacheName("SimpleObjectCache")\n        .setCacheCapacity(10\'000 /* l1EntriesLimit */)\n        .setItemDestructor(\n            [&](cachelib::objcache2::ObjectCacheDestructorData data) {\n              data.deleteObject<Foo>();\n            })\n        .setMaxKeySizeBytes(8)\n        .setAccessConfig(15 /* l1hashTablePower */, 10 /* l1locksPower */)\n        .setNumShards(2) /* optional */\n        .setShardName("my_shard") /* optional */;\n\n    objCache = ObjectCache::create(std::move(config));\n}\n\n')),(0,r.mdx)("h3",{id:"create-a-size-aware-object-cache"},'Create a "size-aware" object-cache'),(0,r.mdx)("p",null,'If your system needs to cap the cache size by bytes where the simple version mentioned above is not good enough, you can enable the "size-awareness" feature.'),(0,r.mdx)("p",null,'A "size-aware" object-cache tracks the object size internally and is limited by both ',(0,r.mdx)("strong",{parentName:"p"},"total size of objects")," (configured by the user as ",(0,r.mdx)("inlineCode",{parentName:"p"},"totalObjectSizeLimit"),") and the ",(0,r.mdx)("strong",{parentName:"p"},"number of objects")," (configured by the user as ",(0,r.mdx)("inlineCode",{parentName:"p"},"l1EntriesLimit"),"). An eviction will be triggered when the total size of objects reaches ",(0,r.mdx)("inlineCode",{parentName:"p"},"totalObjectSizeLimit")," or the total number of objects reaches ",(0,r.mdx)("inlineCode",{parentName:"p"},"l1EntriesLimit")," whichever comes first."),(0,r.mdx)("p",null,"\u2757 ",(0,r.mdx)("strong",{parentName:"p"},"IMPORTANT:"),' A few notes before you try to create a "size-aware" object-cache:'),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"As mentioned above, objects number is still bounded by ",(0,r.mdx)("inlineCode",{parentName:"li"},"l1EntriesLimit"),". And you should make sure you DON'T set ",(0,r.mdx)("inlineCode",{parentName:"li"},"l1EntriesLimit")," either too small or too large. Check out ",(0,r.mdx)("a",{parentName:"li",href:"#how-to-set-l1entrieslimit"},'"how to set l1EntriesLimit"')),(0,r.mdx)("li",{parentName:"ul"},"When inserting a new object into object-cache, you are responsible for calculating the size of that new object and passing the value to object-cache:",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"We provide a util class to help calculate the object size. Check out ",(0,r.mdx)("a",{parentName:"li",href:"#how-to-calculate-object-size"},'"how to calculate object size"'),"."),(0,r.mdx)("li",{parentName:"ul"},"Object-cache maintains the total object size internally based on the object size provided by users. See more in ",(0,r.mdx)("a",{parentName:"li",href:"#how-is-object-size-tracked"},'"how is object size tracked"'),"."))),(0,r.mdx)("li",{parentName:"ul"},"When mutating an existing object in object-cache, you MUST call ",(0,r.mdx)("inlineCode",{parentName:"li"},"mutateObject")," API with a mutation callback (see ",(0,r.mdx)("a",{parentName:"li",href:"#mutate-objects"},'"Mutate Objects"'),"). By calling ",(0,r.mdx)("inlineCode",{parentName:"li"},"mutateObject")," API, object-cache will update the object size internally and there is no calculation needs to be done on your end.")),(0,r.mdx)("h4",{id:"configuration-1"},"Configuration"),(0,r.mdx)("p",null,"To set up a ",(0,r.mdx)("strong",{parentName:"p"},"size-aware")," object-cache, besides the ",(0,r.mdx)("a",{parentName:"p",href:"#configuration"},"settings")," mentioned above, also configure the following settings:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"sizeControllerIntervalMs"),": Set a non-zero period (in milliseconds) to enable the ",(0,r.mdx)("a",{parentName:"li",href:"#what-is-size-controller"},'"size-controller"'),". ",(0,r.mdx)("inlineCode",{parentName:"li"},"0"),' means "size-controller" is disabled.'),(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"Required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"totalObjectSizeLimit"),": The limit of total object size in bytes. If total object size is above this limit, object-cache will start evicting.")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/object_cache/ObjectCache.h"\n\nusing ObjectCache = cachelib::objcache2::ObjectCache<cachelib::LruAllocator>;\nstd::unique_ptr<ObjectCache> objCacheSizeAware;\n\nstruct Foo {\n ...\n};\n\nvoid init() {\n    ObjectCache::Config config;\n    config.setCacheName("SizeAwareObjectCache")\n          .setCacheCapacity(10\'000 /* l1EntriesLimit*/,\n                            30 * 1024 * 1024 * 1024 /* 30GB, totalObjectSizeLimit */,\n                            100 /* sizeControllerIntervalMs */)\n          .setItemDestructor(\n            [&](cachelib::objcache2::ObjectCacheDestructorData data) {\n              data.deleteObject<Foo>();\n            })\n          .setMaxKeySizeBytes(8)\n          .setAccessConfig(15 /* l1hashTablePower */, 10 /* l1locksPower */)\n          .setNumShards(2) /* optional */\n          .setShardName("my_shard") /* optional */;\n\n    objCacheSizeAware = ObjectCache::create(std::move(config));\n}\n\n')),(0,r.mdx)("h4",{id:"how-to-set-l1entrieslimit"},"How to set l1EntriesLimit"),(0,r.mdx)("p",null,"For a size-aware object-cache, user need to set both ",(0,r.mdx)("inlineCode",{parentName:"p"},"l1EntriesLimit")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"totalObjectSizeLimit")," reasonably. ",(0,r.mdx)("inlineCode",{parentName:"p"},"l1EntriesLimit")," is still the upper bound of the number of entries in the cache. If you set ",(0,r.mdx)("inlineCode",{parentName:"p"},"l1EntriesLimit")," too small, ",(0,r.mdx)("inlineCode",{parentName:"p"},"totalObjectSizeLimit")," will be useless, objects will leave the cache as soon as reaching ",(0,r.mdx)("inlineCode",{parentName:"p"},"l1EntriesLimit"),". On the other hand, ",(0,r.mdx)("inlineCode",{parentName:"p"},"l1EntriesLimit")," decides how much mmapped memory we will pre-allocate to store the metadata; setting an incredibly large value can waste huge amount of memory. We would suggest you set ",(0,r.mdx)("inlineCode",{parentName:"p"},"l1EntriesLimit")," to be slightly larger than ",(0,r.mdx)("inlineCode",{parentName:"p"},"totalObjectSizeLimit")," / ",(0,r.mdx)("inlineCode",{parentName:"p"},"avgObjSize")," where ",(0,r.mdx)("inlineCode",{parentName:"p"},"avgObjSize")," is the approximate average object size for your workload."),(0,r.mdx)("h4",{id:"how-to-calculate-object-size"},"How to calculate object size"),(0,r.mdx)("p",null,"When inserting a new object, it is users' responsibility to calculate each object size (i.e. how many bytes are occupied by the object). We provide a util class ",(0,r.mdx)("inlineCode",{parentName:"p"},"ThreadMemoryTracker")," that users can leverage to do the calculation."),(0,r.mdx)("p",null,"The basic idea is:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},"Use Jemalloc util function (",(0,r.mdx)("inlineCode",{parentName:"li"},"thread.allocated")," and ",(0,r.mdx)("inlineCode",{parentName:"li"},"thread.deallocated"),") to calculate allocated memory and deallocated memory in the current thread:")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"  memory usage = allocate memory - deallocated memory\n")),(0,r.mdx)("ol",{start:2},(0,r.mdx)("li",{parentName:"ol"},"Get the currently used memory before and after the object construction, the difference is the object memory:")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"   get before memory usage\n   ...construct object\n   get after memory usage\n   object size = after memory usage - before memory usage\n")),(0,r.mdx)("p",null,"Example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/object_cache/util/ThreadMemoryTracker.h"\n\n// initialize memory tracker only at the beginning\ncachelib::objcache2::ThreadMemoryTracker tMemTracker;\n...\n\nauto beforeMemUsage = tMemTracker.getMemUsageBytes();\n...construct the object\nauto afterMemUsage = tMemTracker.getMemUsageBytes();\n// afterMemUsage < beforeMemUsage occurs very rarely when the current thread\n// spawns children threads and the main thread deallocate memory allocated by\n// the children thread.\nauto objectSize = LIKELY(afterMemUsage > beforeMemUsage)\n                        ? (afterMemUsage - beforeMemUsage)\n                        : 0;\n')),(0,r.mdx)("h4",{id:"how-is-object-size-tracked"},"How is object size tracked"),(0,r.mdx)("p",null,"When a new object is inserted to the cache via ",(0,r.mdx)("inlineCode",{parentName:"p"},"insertOrReplace")," / ",(0,r.mdx)("inlineCode",{parentName:"p"},"insert"),' API, users must pass "object size" to the API (check out ',(0,r.mdx)("a",{parentName:"p",href:"#add-objects"},"Add objects")," section). After that, object-cache knows the size for each cached object and maintains the total object size internally."),(0,r.mdx)("p",null,"User is also allowed to do in-place modification on the object via ",(0,r.mdx)("inlineCode",{parentName:"p"},"mutateObject")," API. With this API, user can pass a mutation callback where mutated size will be calculated internally (check out ",(0,r.mdx)("a",{parentName:"p",href:"#mutate-objects"},"Mutate objects")," section). After that, the size for each cached object and the total object size will be updated. Alternatively, user can directly modify an object's size via ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateObjectSize")," API if the user knows the size difference post-mutation. This latter approach is more error-prone, and we strongly suggest you use ",(0,r.mdx)("inlineCode",{parentName:"p"},"mutateObject")," API which can track size difference automatically."),(0,r.mdx)("h4",{id:"what-is-size-controller"},"What is size controller"),(0,r.mdx)("p",null,'Size-controller is the key component to achieve a "size-aware" object-cache. It is a periodic background worker that dynamically adjusts the ',(0,r.mdx)("strong",{parentName:"p"},"entries limit")," by monitoring the current ",(0,r.mdx)("strong",{parentName:"p"},"total object size")," and ",(0,r.mdx)("strong",{parentName:"p"},"total object number"),"; the new entries limit will still be bounded by ",(0,r.mdx)("inlineCode",{parentName:"p"},"l1EntriesLimit"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"averageObjectSize = totalObjectSize / totalObjectNum\n\nnewEntriesLimit = min(config.totalObjectSizeLimit / averageObjectSize, config.l1EntriesLimit)\n")),(0,r.mdx)("p",null,"The cache will start evicting when total object number exceeds the new entries limit. In this case, we can guarantee the total object size does not exceed ",(0,r.mdx)("inlineCode",{parentName:"p"},"totalObjectSizeLimit")," from long-term perspective."),(0,r.mdx)("p",null,"\u2757 There are a few IMPORTANT things we want to point out here:"),(0,r.mdx)("ol",null,(0,r.mdx)("li",{parentName:"ol"},"it is not a precise control: size-controller CANNOT prevent a sudden increase in object sizes."),(0,r.mdx)("li",{parentName:"ol"},"total object size only tracks the size of actual objects; metadata and cache key size are NOT included. For the details of memory composition, refer to ",(0,r.mdx)("a",{parentName:"li",href:"/docs/facebook/Object_Cache/Object_Cache_Architecture_Guide#design-details"},"object cache design"),".")),(0,r.mdx)("h3",{id:"add-monitoring"},"Add monitoring"),(0,r.mdx)("p",null,"After the initialization, you should also add ",(0,r.mdx)("a",{parentName:"p",href:"../Cache_Monitoring/Cache_Admin_Overview"},"cacheAdmin")," to enable ",(0,r.mdx)("a",{parentName:"p",href:"../Cache_Monitoring/monitoring"},"monitoring")," for object-cache."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/facebook/admin/CacheAdmin.h"\n\nstd::unique_ptr<cachelib::CacheAdmin> cacheAdmin;\n\nvoid init() {\n  ... setting up the object-cache here\n\n  CacheAdmin::Config adminConfig; // default config should work just fine\n  adminConfig.oncall = "my_team_oncall_shortname";\n  cacheAdmin = std::make_unique<CacheAdmin>(*objCache, adminConfig);\n}\n')),(0,r.mdx)("h2",{id:"use-object-cache"},"Use object-cache"),(0,r.mdx)("h3",{id:"add-objects"},"Add objects"),(0,r.mdx)("p",null,"To add objects to object-cache, call ",(0,r.mdx)("inlineCode",{parentName:"p"},"insertOrReplace")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"insert")," API:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\nstd::tuple<bool, std::shared_ptr<T>, std::shared_ptr<T>> insertOrReplace(\n    folly::StringPiece key,\n    std::unique_ptr<T> object,\n    size_t objectSize = 0,\n    uint32_t ttlSecs = 0);\n\ntemplate <typename T>\nstd::pair<AllocStatus, std::shared_ptr<T>> insert(folly::StringPiece key,\n                                                  std::unique_ptr<T> object,\n                                                  size_t objectSize = 0,\n                                                  uint32_t ttlSecs = 0);\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"insertOrReplace"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Insert an object into the cache with a given key."),(0,r.mdx)("li",{parentName:"ul"},"If the key exists in the cache, it will be replaced with new object."),(0,r.mdx)("li",{parentName:"ul"},"Return a tuple of allocation status (",(0,r.mdx)("inlineCode",{parentName:"li"},"kSuccess")," or ",(0,r.mdx)("inlineCode",{parentName:"li"},"kAllocError"),") , ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," of newly inserted object (even if the object is not successfully inserted, it will still be converted to a ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," and returned), and ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," of the old object that has been replaced (if no replacement happened, ",(0,r.mdx)("inlineCode",{parentName:"li"},"nullptr")," will be returned)."))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"insert"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Unique insert an object into the cache with a given key."),(0,r.mdx)("li",{parentName:"ul"},"If the key exists in the cache, the new object will NOT be inserted."),(0,r.mdx)("li",{parentName:"ul"},"Return a pair of allocation status (",(0,r.mdx)("inlineCode",{parentName:"li"},"kSuccess"),", ",(0,r.mdx)("inlineCode",{parentName:"li"},"kKeyAlreadyExists")," or ",(0,r.mdx)("inlineCode",{parentName:"li"},"kAllocError"),") and ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," of newly inserted object. Note that even if the object is not successfully inserted, it will still be converted to a ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," and returned.")))),(0,r.mdx)("p",null,"Parameters:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"key"),": object key"),(0,r.mdx)("li",{parentName:"ul"},"(",(0,r.mdx)("strong",{parentName:"li"},"required"),") ",(0,r.mdx)("inlineCode",{parentName:"li"},"object"),": ",(0,r.mdx)("inlineCode",{parentName:"li"},"unique_ptr")," of the object to be inserted"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"objectSize"),": size of the object to be inserted",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"0")),(0,r.mdx)("li",{parentName:"ul"},"for non-size-aware ones, always leave the value as ",(0,r.mdx)("inlineCode",{parentName:"li"},"0")),(0,r.mdx)("li",{parentName:"ul"},"for size-aware ones, ",(0,r.mdx)("strong",{parentName:"li"},"MUST provide a non-zero value")," (check out ",(0,r.mdx)("a",{parentName:"li",href:"#how-to-calculate-object-size"},'"how to calculate object size"'),")"))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"ttlSecs"),": Time To Live(seconds) for the object",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"default to ",(0,r.mdx)("inlineCode",{parentName:"li"},"0")," means object has no expiring time.")))),(0,r.mdx)("p",null,"Example(non-size-aware):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"...\nauto [allocStatus, ptr, oldPtr] =\n    objcache->insertOrReplace(key,\n                              std::move(foo),\n                              0 /*objectSize tracking is not enabled*/,\n                              ttlSecs /*optional*/);\nif (allocStatus == ObjectCache::AllocStatus::kSuccess) {\n  ...\n  return ptr;\n} else { // ObjectCache::AllocStatus::kAllocError\n  ...\n}\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"...\nauto [allocStatus, ptr] =\n    objcache->insert(key,\n                     std::move(foo),\n                     0 /*objectSize tracking is not enabled*/,\n                     ttlSecs /*optional*/);\nif (allocStatus == ObjectCache::AllocStatus::kSuccess) {\n  ...\n  return ptr;\n} else if (allocStatus == ObjectCache::AllocStatus::kKeyAlreadyExists) {\n  ...\n} else { // ObjectCache::AllocStatus::kAllocError\n  ...\n}\n")),(0,r.mdx)("p",null,"Example(size-aware):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"...\nauto [allocStatus, ptr, oldPtr] =\n    objcacheSizeAware->insertOrReplace(key,\n                                       std::move(foo),\n                                       objectSize /* must be non-zero */,\n                                       ttlSecs /*optional*/);\nif (allocStatus == ObjectCache::AllocStatus::kSuccess) {\n  ...\n  return ptr;\n} else { // ObjectCache::AllocStatus::kAllocError\n  ...\n}\n...\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"...\nauto [allocStatus, ptr] =\n    objcacheSizeAware->insert(key,\n                              std::move(foo),\n                              objectSize /* must be non-zero*/,\n                              ttlSecs /*optional*/);\nif (allocStatus == ObjectCache::AllocStatus::kSuccess) {\n  ...\n  return ptr;\n} else if (allocStatus == ObjectCache::AllocStatus::kKeyAlreadyExists) {\n  ...\n} else { // ObjectCache::AllocStatus::kAllocError\n  ...\n}\n...\n")),(0,r.mdx)("h3",{id:"get-objects"},"Get objects"),(0,r.mdx)("p",null,"To get objects from object-cache, call ",(0,r.mdx)("inlineCode",{parentName:"p"},"find")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"findToWrite")," API:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\nstd::shared_ptr<const T> find(folly::StringPiece key);\n\ntemplate <typename T>\nstd::shared_ptr<T> findToWrite(folly::StringPiece key);\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"find"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Look up an object in ",(0,r.mdx)("strong",{parentName:"li"},"read-only")," access."),(0,r.mdx)("li",{parentName:"ul"},"Return a ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," to a const version of the object if found; ",(0,r.mdx)("inlineCode",{parentName:"li"},"nullptr")," if not found."))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"findToWrite"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Look up an object in ",(0,r.mdx)("strong",{parentName:"li"},"mutable")," access."),(0,r.mdx)("li",{parentName:"ul"},"Return a ",(0,r.mdx)("inlineCode",{parentName:"li"},"shared_ptr")," to a mutable version of the object if found; ",(0,r.mdx)("inlineCode",{parentName:"li"},"nullptr")," if not found.")))),(0,r.mdx)("p",null,"\u2757 ",(0,r.mdx)("strong",{parentName:"p"},"IMPORTANT:")),(0,r.mdx)("p",null,"Separating write and read traffic is quite important here. A misuse of these two APIs can lead to unreasonable eviction result because we only promotes read traffic by default. For more details, check out ",(0,r.mdx)("a",{parentName:"p",href:"/docs/Cache_Library_User_Guides/eviction_policy#configuration"},'"Eviction policy"'),". The guidance here is:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Always consider ",(0,r.mdx)("inlineCode",{parentName:"li"},"find")," API first;"),(0,r.mdx)("li",{parentName:"ul"},"Choose ",(0,r.mdx)("inlineCode",{parentName:"li"},"findToWrite")," API only when an in-place modification needs to happen.")),(0,r.mdx)("p",null,"Example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'std::shared_ptr<const Foo> foo = objcache->find<Foo>("foo");\nif (foo !== nullptr) {\n    ... some read operation\n}\n')),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'std::shared_ptr<Foo> mutableFoo = objcache->findToWrite<Foo>("foo");\nif (mutableFoo !== nullptr) {\n    ... some write operation\n}\n\n')),(0,r.mdx)("h3",{id:"mutate-objects"},"Mutate objects"),(0,r.mdx)("p",null,"If size-awareness is enabled, to do in-place modification on an object, you must call ",(0,r.mdx)("inlineCode",{parentName:"p"},"mutateObject")," API:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\nvoid mutateObject(const std::shared_ptr<T>& object,\n                  std::function<void()> mutateCb);\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"there are two parameters:",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"object"),": a shared pointer of the object to be mutated. This shared pointer must be fetched from object-cache APIs ",(0,r.mdx)("inlineCode",{parentName:"li"},"findToWrite"),", ",(0,r.mdx)("inlineCode",{parentName:"li"},"insertOrReplace")," or ",(0,r.mdx)("inlineCode",{parentName:"li"},"insert"),"."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"mutateCb"),": a callback containing mutation logic.")))),(0,r.mdx)("p",null,"What should happen inside ",(0,r.mdx)("inlineCode",{parentName:"p"},"mutateCb")," is:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"allocation of the new value"),(0,r.mdx)("li",{parentName:"ul"},"deallocation of the old value to be replaced")),(0,r.mdx)("p",null,"A common incorrect usage is:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"auto ptr = objCache->findToWrite<ObjectType>(...);\nauto newPtr = std::make_unique<ObjectType>(...);\nauto mutateCb = [&ptr, &newPtr]() {\n    // (Bad!) move-assignment from new object into existing\n    // We don't know the size of new object\n    *ptr = std::move(*newPtr);\n};\n")),(0,r.mdx)("p",null,"To correct this, you should move the construction of ",(0,r.mdx)("inlineCode",{parentName:"p"},"newPtr")," into ",(0,r.mdx)("inlineCode",{parentName:"p"},"mutateCb"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"auto ptr = objCache->findToWrite<ObjectType>(...);\nauto mutateCb = [&ptr]() {\n    // (Good!) construct new object in the callback and then\n    // move-assignment into existing object. We know the size\n    // of new object, and can calculate the delta correctly\n    auto newPtr = std::make_unique<ObjectType>(...);\n    *ptr = std::move(*newPtr);\n};\n")),(0,r.mdx)("p",null,"Example (",(0,r.mdx)("inlineCode",{parentName:"p"},"std::string"),"):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'auto stringPtr = objcache->findToWrite<std::string>("cacheKey");\n\n// set a value\nauto mutateCb1 = [&stringPtr]() { *stringPtr = "tiny"; };\n\n// replace the value with a longer string\nauto mutateCb2 = [&stringPtr]() {\n    *stringPtr = "longgggggggggggggggggggggggggggstringgggggggggggg";\n};\n\n// replace the value with a shorter string\nauto mutateCb3 = [&stringPtr]() {\n    *stringPtr = "short";\n    // optional: we can call \u201cshrink_to_fit\u201d to deallocate the memory when the new string is shorter\n    // (*found).shrink_to_fit();\n};\n\nobjcache->mutateObject(stringPtr, std::move(mutateCb1));\nobjcache->mutateObject(stringPtr, std::move(mutateCb2));\nobjcache->mutateObject(stringPtr, std::move(mutateCb3));\n\n')),(0,r.mdx)("p",null,"Example (",(0,r.mdx)("inlineCode",{parentName:"p"},"std::vector"),"):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'using ObjectType = std::vector<Foo>;\n\nauto vectorPtr = objcache->findToWrite<ObjectType>("cacheKey");\n\n// add an entry using emplace_back\nauto mutateCb1 = [&vectorPtr]() { vectorPtr->emplace_back(Foo{1, 2, 3}); };\n\n// add another entry using push_back\nauto mutateCb2 = [&vectorPtr]() { vectorPtr->push_back(Foo{4, 5, 6}); };\n\n// remove the entry from the end using pop_back\nauto mutateCb3 = [&vectorPtr]() {\n    vectorPtr->pop_back();\n    // optional: we can call \u201cshrink_to_fit\u201d to deallocate unnecessary memory\n    // vectorPtr->shrink_to_fit();\n};\n\nobjcache->mutateObject(vectorPtr, std::move(mutateCb1));\nobjcache->mutateObject(vectorPtr, std::move(mutateCb2));\nobjcache->mutateObject(vectorPtr, std::move(mutateCb3));\n')),(0,r.mdx)("p",null,"Example (",(0,r.mdx)("inlineCode",{parentName:"p"},"std::unordere_map"),"):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'using ObjectType = std::unordered_map<std::string, std::string>;\n\nauto mapPtr = objcache->findToWrite<ObjectType>("cacheKey");\n\n// add an entry\nauto mutateCb1 = [&mapPtr]() { (*mapPtr)["key"] = "tiny"; };\n\n// replace the entry with a longer string\nauto mutateCb2 = [&mapPtr]() {\n    (*mapPtr)["key"] = "longgggggggggggggggggggggggggggstringgggggggggggg";\n};\n\n// remove the entry\nauto mutateCb3 = [&mapPtr]() { mapPtr->erase("key"); };\n\nobjcache->mutateObject(mapPtr, std::move(mutateCb1));\nobjcache->mutateObject(mapPtr, std::move(mutateCb2));\nobjcache->mutateObject(mapPtr, std::move(mutateCb3));\n')),(0,r.mdx)("h3",{id:"remove-objects"},"Remove objects"),(0,r.mdx)("p",null,"To remove objects from object-cache, call ",(0,r.mdx)("inlineCode",{parentName:"p"},"remove")," API:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"bool remove(folly::StringPiece key);\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"remove"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Remove an object from cache by its key. No-op if the key not found."),(0,r.mdx)("li",{parentName:"ul"},"Return ",(0,r.mdx)("inlineCode",{parentName:"li"},"false")," if the key is not found in object-cache.")))),(0,r.mdx)("p",null,"Example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'// objcache is empty\nobjcache->remove<Foo>("foo"); // no-op, return `false`\n\nobjcache->insertOrReplace<Foo>("foo", std::move(foo));\n...\n\nobjcache->remove<Foo>("foo"); // foo will be removed, return `true`\n')),(0,r.mdx)("h2",{id:"monitor-object-cache"},"Monitor object-cache"),(0,r.mdx)("p",null,"Once CacheAdmin is added, Object-Cache provides the same set of stats as provided in the regular CacheLib. Besides that, if size-awareness is enabled, there are Object-Cache specific stats to monitor the heap memory usage:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"object_size_bytes:",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"tracking the total object size in bytes on the heap"),(0,r.mdx)("li",{parentName:"ul"},"usage: cachelib.<cache_name>.objcache.object_size_bytes"))),(0,r.mdx)("li",{parentName:"ul"},"jemalloc fragmentation rate:",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"tracking the jemalloc (external) fragmentation rate - (below 15% is an acceptable rate)"),(0,r.mdx)("li",{parentName:"ul"},"usage:",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"jemalloc_active_bytes: cachelib.<cache_name>.objcache.jemalloc_active_bytes"),(0,r.mdx)("li",{parentName:"ul"},"jemalloc_allocated_bytes: cachelib.<cache_name>.objcache.jemalloc_allocated_bytes"),(0,r.mdx)("li",{parentName:"ul"},"jemalloc fragmentation rate = (jemalloc_active_bytes - jemalloc_allocated_bytes) / jemalloc_active_bytes"))),(0,r.mdx)("li",{parentName:"ul"},"note: if the jemalloc fragmentation rate is very high(e.g. >20%), your service can be at the risk of OOM and you should consider ",(0,r.mdx)("inlineCode",{parentName:"li"},"config.enableFragmentationTracking()")," to bound the cache by total object size AND the approximate fragmentation bytes generated by them"))),(0,r.mdx)("li",{parentName:"ul"},"object size distribution:",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"histogram of object size (on the heap)"),(0,r.mdx)("li",{parentName:"ul"},"usage:",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"set config.objectSizeDistributionTrackingEnabled to be true"),(0,r.mdx)("li",{parentName:"ul"},"regex(cachelib.<cache_name>.objcache.size_distribution.object_size_bytes.","*","),"))),(0,r.mdx)("li",{parentName:"ul"},"note: this stat is only for debugging/experimental purpose and should never be enabled in production since the calculation is very cpu-intensive")))),(0,r.mdx)("h2",{id:"ttl-time-to-live"},"TTL (Time To Live)"),(0,r.mdx)("p",null,"Object-Cache provides the same TTL support as in regular cacheLib."),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"TTL is at the granularity of seconds"),(0,r.mdx)("li",{parentName:"ul"},"Object will not be accessible if it is beyond the TTL (i.e. ",(0,r.mdx)("inlineCode",{parentName:"li"},"find")," API will return ",(0,r.mdx)("inlineCode",{parentName:"li"},"nullptr"),")"),(0,r.mdx)("li",{parentName:"ul"},"Object could still exist in the cache if it is beyond the TTL. We use ",(0,r.mdx)("inlineCode",{parentName:"li"},"Reaper")," (cachelib's TTL worker) to periodically remove expired objects from the cache. By default, the Reaper runs every 5 seconds. Users can also set a different interval via ",(0,r.mdx)("inlineCode",{parentName:"li"},"ObjectCacheConfig"),":")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"ObjectCache::Config config;\n...\nconfig.setItemReaperInterval(std::chrono::milliseconds{10000}) // reaper will run every 10 seconds;\n")),(0,r.mdx)("h3",{id:"set-ttl"},"Set TTL"),(0,r.mdx)("p",null,"As what mentioned in ",(0,r.mdx)("a",{parentName:"p",href:"#add-objects"},'"Add objects"')," section, set the ttl for an object upon insertion:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"objcache->insertOrReplace(key,\n                          std::move(obj),\n                          objectSize,\n                          10 /* ttl is 10 seconds */);\n\nobjcache->insert(key,\n                 std::move(obj),\n                 objectSize,\n                 10 /* ttl is 10 seconds */);\n")),(0,r.mdx)("h3",{id:"get-ttl"},"Get TTL"),(0,r.mdx)("p",null,"To get a cached object's ttl, we provide ",(0,r.mdx)("inlineCode",{parentName:"p"},"getExpiryTimeSec")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"getConfiguredTtl")," APIs:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\nuint32_t getExpiryTimeSec(const std::shared_ptr<T>& object) const;\n\ntemplate <typename T>\nstd::chrono::seconds getConfiguredTtl(const std::shared_ptr<T>& object) const;\n\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"getExpiryTimeSec"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Return the expiry timestamp of the passed object (in seconds)"))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"getConfiguredTtl"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Return the configured TTL of the passed object (in seconds)")))),(0,r.mdx)("p",null,"\u2757 ",(0,r.mdx)("strong",{parentName:"p"},"IMPORTANT:")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"The passed object shared pointer must be fetched from object-cache APIs (e.g. find, insert APIs).")),(0,r.mdx)("p",null,"Usage 1:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'auto obj = objcache->find<T>("key");\nauto expiryTimeSec = objcache->getExpiryTimeSec(obj);\nif (expiryTime != 0) { // ttl is set\n    if (expiryTimeSec < util::getCurrentTimeSec()) { // not expired\n        ...\n    } else {\n        ...\n    }\n}\n')),(0,r.mdx)("p",null,"Usage 2:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'auto obj = objcache->find<T>("key");\nauto ttlSecs = objcache->getConfiguredTtl(obj).count();\nif (ttlSecs != 0) { // ttl is set\n    ...\n}\n')),(0,r.mdx)("p",null,"Object's ",(0,r.mdx)("inlineCode",{parentName:"p"},"expiryTime")," is also accessible via ",(0,r.mdx)("inlineCode",{parentName:"p"},"ObjectCacheDestructorData"),". One usage could be checking whether the object is expired when it's leaving the cache:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"ObjectCache::Config config;\n...\nconfig.setItemDestructor(\n       [&](cachelib::objcache2::ObjectCacheDestructorData data) {\n  ...\n  if (data.expiryTime >= util::getCurrentTimeSec()) { // expired\n     ...\n  }\n  ...\n  data.deleteObject<T>();\n});\n")),(0,r.mdx)("h3",{id:"update-ttl"},"Update TTL"),(0,r.mdx)("p",null,"To update a cached object's ttl, we provide ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateExpiryTimeSec")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"extendTtl")," APIs:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\nbool updateExpiryTimeSec(std::shared_ptr<T>& object,\n                         uint32_t newExpiryTimeSecs);\n\ntemplate <typename T>\nbool extendTtl(std::shared_ptr<T>& object, std::chrono::seconds ttl);\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"updateExpiryTimeSec"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Update the expiry timestamp to ",(0,r.mdx)("inlineCode",{parentName:"li"},"newExpiryTimeSecs")),(0,r.mdx)("li",{parentName:"ul"},"Return ",(0,r.mdx)("inlineCode",{parentName:"li"},"true")," if the expiry time was successfully updated"))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"extendTtl"),":",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"Extend the expiry timestamp to ",(0,r.mdx)("inlineCode",{parentName:"li"},"now + ttl")," (in seconds)"),(0,r.mdx)("li",{parentName:"ul"},"Return ",(0,r.mdx)("inlineCode",{parentName:"li"},"true")," if the expiry time was successfully extended")))),(0,r.mdx)("p",null,"\u2757 ",(0,r.mdx)("strong",{parentName:"p"},"IMPORTANT:")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"The passed object shared pointer must be fetched from object-cache APIs (e.g. find, insert APIs).")),(0,r.mdx)("p",null,"Usage 1:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'auto obj = objcache->findToWrite<T>("key"); // calling find() API is also fine\nobjcache->updateExpiryTimeSec(obj, util::getCurrentTimeSec() + 300 /* 5mins */); // expiryTime becomes now + 5mins\n...\n')),(0,r.mdx)("p",null,"Usage 2:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'auto obj = objcache->findToWrite<T>("key"); // calling find() API is also fine\nobjcache->extendTtl(obj, std::chrono::seconds(300) /* 5 mins*/); // expiryTime becomes now + 5mins\n...\n')),(0,r.mdx)("h2",{id:"cache-persistence"},"Cache Persistence"),(0,r.mdx)("p",null,"Cache persistence is an opt-in feature in object-cache to persist objects across process restarts. It is useful when you want to restart your binary without losing previously cached objects. Currently we support cache persistence in a multi-thread mode where user can configure the parallelism degree to adjust the persistence/recovery speed. This feature only works when you restart the process in the same machine. Across machines persistence is not supported."),(0,r.mdx)("h3",{id:"configure-cache-persistence"},"Configure cache persistence"),(0,r.mdx)("p",null,"To enable cache persistence, you need to configure the following parameters:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"threadCount"),": number of threads to work on persistence/recovery concurrently"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"persistBasefilePath"),": ",(0,r.mdx)("strong",{parentName:"li"},"file")," path to save the persistent data (a ",(0,r.mdx)("strong",{parentName:"li"},"directory")," path will not work)",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},'cache metadata will be saved in "persistBasefilePath";'),(0,r.mdx)("li",{parentName:"ul"},'objects will be saved in "persistBasefilePath_i", i in [0, threadCount)'))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"serializeCallback"),": callback to serialize an object, used for object persisting",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"it takes ",(0,r.mdx)("inlineCode",{parentName:"li"},"ObjectCache::Serializer")," which has",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"serialize<ThriftT>()")," API that serializes the object of type ",(0,r.mdx)("inlineCode",{parentName:"li"},"ThriftT")," and returns a ",(0,r.mdx)("inlineCode",{parentName:"li"},"folly::IOBuf"),";"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"serialize<T, ThriftT>(toThriftCb)")," API that requires a callback ",(0,r.mdx)("inlineCode",{parentName:"li"},"std::function<ThriftT(T*)>")," to convert non-Thrift type to Thrift type, then do the same thing as the above."))))),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"deserializeCallback"),": callback to deserialize an object, used for object recovery",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"it takes ",(0,r.mdx)("inlineCode",{parentName:"li"},"ObjectCache::Deserializer")," which has",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"deserialize<ThriftT>()")," API that deserializes the object of type ",(0,r.mdx)("inlineCode",{parentName:"li"},"ThriftT")," and inserts it to the cache; returns ",(0,r.mdx)("inlineCode",{parentName:"li"},"true")," when the insertion is successful;"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"deserialize<T, ThriftT>(fromThriftCb)")," API that requires a callback ",(0,r.mdx)("inlineCode",{parentName:"li"},"std::function<T(ThriftT)>")," to convert Thrift type to non-Thrift type, then do the same thing as the above.")))))),(0,r.mdx)("p",null,"#1. If you store Thrift objects in object-cache, follow the following examples:"),(0,r.mdx)("p",null,"Example (single-type):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"ObjectCache::Config config;\n...\nconfig.enablePersistence(threadCount,\n                         persistBaseFilePath,\n                           [&](ObjectCache::Serializer serializer) {\n                             return serializer.serialize<ThriftType>();\n                           },\n                          [&](ObjectCache::Deserializer deserializer) {\n                             return deserializer.deserialize<ThriftType>();\n                           });\n\n\n")),(0,r.mdx)("p",null,"Example (multi-type):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"ObjectCache::Config config;\n...\nconfig.enablePersistence(threadCount,\n                         persistBaseFilePath,\n                           [&](ObjectCache::Serializer serializer) {\n                   switch (user_defined_getType(serializer.key)) {\n                         case user_defined_Type::ThriftType1:\n                              return serializer.serialize<ThriftType1>();\n                         case user_defined_Type::ThriftType2:\n                              return serializer.serialize<ThriftType2>();\n                         case user_defined_Type::ThriftType3:\n                              return serializer.serialize<ThriftType3>();\n                         default:\n                              \u2026\n                           },\n                          [&](ObjectCache::Deserializer deserializer) {\n                     switch (user_defined_getType(serializer.key)) {\n                         case user_defined_Type::ThriftType1:\n                              return deserializer.deserialize<ThriftType1>();\n                         case user_defined_Type::ThriftType2:\n                              return deserializer.deserialize<ThriftType2>();\n                         case user_defined_Type::ThriftType3:\n                              return deserializer.deserialize<ThriftType3>();\n                         default:\n                              \u2026\n                           });\n\n")),(0,r.mdx)("p",null,"#2. If you store non-Thrift objects in object-cache, you need to create a Thrift counterpart."),(0,r.mdx)("p",null,"Example (single-type):"),(0,r.mdx)("p",null,"Assuming you store C++ objects of type ",(0,r.mdx)("inlineCode",{parentName:"p"},"Foo")," in object-cache and build a Thrift type ",(0,r.mdx)("inlineCode",{parentName:"p"},"ThriftFoo")," for cache persistence."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"// object.h\nclass Foo {\n    int a;\n    int b;\n    int c;\n}\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"// object.thrift\nstruct ThriftFoo {\n  1: i32 a;\n  2: i32 b;\n  3: i32 c;\n}\n\n")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"ObjectCache::Config config;\n...\nconfig..enablePersistence(\n            threadsCount, persistBaseFilePath,\n            [&](ObjectCache::Serializer serializer) {\n              return serializer.serialize<Foo, ThriftFoo>(\n                  [](Foo* foo) -> ThriftFoo {\n                    ThriftFoo obj;\n                    obj.a() = foo->a;\n                    obj.b() = foo->b;\n                    obj.c() = foo->c;\n                    return obj;\n                  });\n            },\n            [&](ObjectCache::Deserializer deserializer) {\n              return deserializer.deserialize<Foo, ThriftFoo>(\n                  [](ThriftFoo thriftObj) -> Foo {\n                    return Foo{*thriftObj.a(), *thriftObj.b(), *thriftObj.c()};\n                  });\n            });\n")),(0,r.mdx)("p",null,"Same rule applies to multi-type use cases."),(0,r.mdx)("h3",{id:"use-cache-persistence"},"Use cache persistence"),(0,r.mdx)("p",null,"Once cache persistence is enabled, to persist or recover objects, it is as simple as an API call."),(0,r.mdx)("p",null,"To persist, user should call ",(0,r.mdx)("inlineCode",{parentName:"p"},"persist()")," API upon cache shutdown:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"objCache->persist(); // all non-expired objects will be saved to files\n")),(0,r.mdx)("p",null,"To recover, user should call ",(0,r.mdx)("inlineCode",{parentName:"p"},"recover()")," API upon cache restart:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"objCache->recover(); // all saved non-expired objects will be recovered\n")),(0,r.mdx)("p",null,"Notes:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Expired objects won't be persisted or recovered."),(0,r.mdx)("li",{parentName:"ul"},"To correctly recover objects, user must put the same ",(0,r.mdx)("inlineCode",{parentName:"li"},"persistBaseFilePath")," as the previous persistent cache instance."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"threadCount")," is for persisting parallelism of the current cache instance. Recovery will always use the same ",(0,r.mdx)("inlineCode",{parentName:"li"},"threadCount")," as the previous persistent cache instance. For example:")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'config1.enablePersistence(5 /*threadCount*/, "baseFile_1", ..., ...);\nauto objCache1 = ObjectCache::create(config1);\n...\n// ... shutting down cache\nobjCache1.persist(); // threadCount = 5\n\n...\nconfig2.enablePersistence(10 /*threadCount*/, "baseFile_1", ..., ...);\nauto objCache2 = ObjectCache::create(config2);\n//... restarting cache\nobjCache2.recover(); // threadCount = 5\n...\n//... shutting down cache\nobjCache2.persist(); // threadCount = 10\n\n')))}u.isMDXComponent=!0}}]);