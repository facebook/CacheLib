"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[4410],{15680:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>m,mdx:()=>f,useMDXComponents:()=>h,withMDXComponents:()=>c});var a=n(96540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var d=a.createContext({}),c=function(e){return function(t){var n=h(t.components);return a.createElement(e,r({},t,{components:n}))}},h=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=h(e.components);return a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=h(n),m=i,u=c["".concat(o,".").concat(m)]||c[m]||p[m]||r;return n?a.createElement(u,l(l({ref:t},d),{},{components:n})):a.createElement(u,l({ref:t},d))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},91320:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>d,toc:()=>h});var a=n(9668),i=n(21367),r=(n(96540),n(15680)),o=["components"],l={id:"FDP_enabled_Cache",title:"FDP enabled cache"},s=void 0,d={unversionedId:"Cache_Library_User_Guides/FDP_enabled_Cache",id:"Cache_Library_User_Guides/FDP_enabled_Cache",title:"FDP enabled cache",description:"NVMe\xae Flexible Data Placement (NVMe\xae FDP)",source:"@site/docs/Cache_Library_User_Guides/FDP_enabled_Cache.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/FDP_enabled_Cache",permalink:"/docs/Cache_Library_User_Guides/FDP_enabled_Cache",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/FDP_enabled_Cache.md",tags:[],version:"current",frontMatter:{id:"FDP_enabled_Cache",title:"FDP enabled cache"},sidebar:"userguideSidebar",previous:{title:"Structured cache",permalink:"/docs/Cache_Library_User_Guides/Structured_Cache"},next:{title:"Tuning DRAM cache efficiency",permalink:"/docs/Cache_Library_User_Guides/Tuning_DRAM_cache_efficiency"}},c={},h=[{value:"NVMe\xae Flexible Data Placement (NVMe\xae FDP)",id:"nvme-flexible-data-placement-nvme-fdp",level:3},{value:"How does CacheLib use FDP?",id:"how-does-cachelib-use-fdp",level:3},{value:"FDP support within Navy",id:"fdp-support-within-navy",level:3},{value:"When should FDP be enabled?",id:"when-should-fdp-be-enabled",level:3},{value:"Building the code for FDP",id:"building-the-code-for-fdp",level:3},{value:"How to enable FDP in the SSD?",id:"how-to-enable-fdp-in-the-ssd",level:3},{value:"How to enable FDP in CacheLib?",id:"how-to-enable-fdp-in-cachelib",level:3},{value:"Qemu FDP emulation",id:"qemu-fdp-emulation",level:3},{value:"Results with and without FDP",id:"results-with-and-without-fdp",level:3}],m={toc:h};function p(e){var t=e.components,l=(0,i.A)(e,o);return(0,r.mdx)("wrapper",(0,a.A)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("h3",{id:"nvme-flexible-data-placement-nvme-fdp"},"NVMe\xae Flexible Data Placement (NVMe\xae FDP)"),(0,r.mdx)("p",null,"NVM Express\xae(NVMe\xae) released the ratified technical proposal T","P4146","a Flexible Data Placement (FDP) that defines a new method for placing host data (logical blocks) into the SSD in an effort to reduce SSD ",(0,r.mdx)("a",{parentName:"p",href:"https://nvmexpress.org/nvmeflexible-data-placement-fdp-blog/"},"Write Amplification Factor (WAF)"),". This provides the host a mechanism to control which of its data is placed into different sets of physical locations of the SSD (NAND blocks) called Reclaim Units. The host is able to write into multiple such Reclaim Units at a time allowing the host to isolate its data that has different lifetime. For more information on NVMe\xae FDP and various use cases refer this document: ",(0,r.mdx)("a",{parentName:"p",href:"https://download.semiconductor.samsung.com/resources/white-paper/FDP_Whitepaper_102423_Final_10130020003525.pdf"},"Introduction to FDP"),"."),(0,r.mdx)("h3",{id:"how-does-cachelib-use-fdp"},"How does CacheLib use FDP?"),(0,r.mdx)("p",null,"CacheLib's BigHash and BlockCache produce distinct IO patterns on the SSD. BigHash generates a random write pattern while BlockCache generates a sequential write pattern. In a conventional SSD, these writes get mixed up in the physical NAND media. This intermixing can lead to a higher SSD Write Amplification Factor (WAF). To combat this in production environments CacheLib uses upto ",(0,r.mdx)("a",{parentName:"p",href:"https://www.usenix.org/system/files/osdi20-berg.pdf"},"50% of the SSD as host over-provisioning"),". The Flexible Data Placement (FDP) support within CacheLib aims to segregate the BigHash and BlockCache data of CacheLib within the SSDs. This reduces the device WAF even when configured with 0% host over-provisioning and improves device endurance. FDP support within Navy is optional."),(0,r.mdx)("table",null,(0,r.mdx)("thead",{parentName:"table"},(0,r.mdx)("tr",{parentName:"thead"},(0,r.mdx)("th",{parentName:"tr",align:"center"},(0,r.mdx)("img",{src:n(13964).A,width:"643",height:"676"})))),(0,r.mdx)("tbody",{parentName:"table"},(0,r.mdx)("tr",{parentName:"tbody"},(0,r.mdx)("td",{parentName:"tr",align:"center"},(0,r.mdx)("em",{parentName:"td"},"CacheLib IO Flow with and without FDP"))))),(0,r.mdx)("p",null,"Since FDP directives are not yet supported by the Linux kernel block layer interface, we have used Linux kernel ",(0,r.mdx)("a",{parentName:"p",href:"https://www.usenix.org/system/files/fast24-joshi.pdf"},"I/O Passthru")," mechanism (which leverages ",(0,r.mdx)("a",{parentName:"p",href:"https://www.usenix.org/system/files/fast24-joshi.pdf"},"io_uring_cmd interface"),") as seen in the figure. "),(0,r.mdx)("h3",{id:"fdp-support-within-navy"},"FDP support within Navy"),(0,r.mdx)("p",null,"The ",(0,r.mdx)("inlineCode",{parentName:"p"},"FdpNvme")," class embeds all the FDP related semantics and APIs and is used  by the ",(0,r.mdx)("inlineCode",{parentName:"p"},"FileDevice")," class. This can be extended to other modules in the future if they desire to use FDP support. The below are some key functions added to the ",(0,r.mdx)("inlineCode",{parentName:"p"},"FdpNvme")," class related to FDP and iouring_cmd."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},"\n  // Allocates an FDP specific placement handle to modules using FdpNvme like Block Cache and Big Hash.\n  // This handle will be interpreted by the device for data placement.\n  int allocateFdpHandle();\n\n  // Prepares the Uring_Cmd sqe for read/write command with FDP directives.\n  void prepFdpUringCmdSqe(struct io_uring_sqe& sqe,\n                          void* buf,\n                          size_t size,\n                          off_t start,\n                          uint8_t opcode,\n                          uint8_t dtype,\n                          uint16_t dspec);\n")),(0,r.mdx)("h3",{id:"when-should-fdp-be-enabled"},"When should FDP be enabled?"),(0,r.mdx)("p",null,"When using Navy, FDP can help play a role in improving SSD endurance in comparison to Non-FDP. If the workload has both small objects and large objects, FDP's WAF gains will most likely be evident because FDP segregates these two in the SSD. In cases like CacheLib's CDN workload where BigHash is typically not configured, this FDP based segregation will make no difference to SSD WAF. On the other hand with CacheLib's KV Cache workload where both Big Hash and Block Cache are configured, we see the gains from using FDP. We showcase the WAF gains in the results section below. "),(0,r.mdx)("h3",{id:"building-the-code-for-fdp"},"Building the code for FDP"),(0,r.mdx)("blockquote",null,(0,r.mdx)("p",{parentName:"blockquote"},(0,r.mdx)("strong",{parentName:"p"}," ",(0,r.mdx)("em",{parentName:"strong"},"Note on building the code:")," ")," As the FDP path uses IOUring for I/Os as mentioned above, make sure to install the ",(0,r.mdx)("a",{parentName:"p",href:"https://github.com/axboe/liburing"},"liburing library")," before building the CacheLib code.  ")),(0,r.mdx)("p",null,"The method to build the CacheLib code remains unchanged. Refer ",(0,r.mdx)("a",{parentName:"p",href:"/docs/installation/"},"Build and Installation")," for the detailed steps. After building the code, to run a CacheLib instance with FDP make sure to enable FDP both in the SSD and CacheLib."),(0,r.mdx)("h3",{id:"how-to-enable-fdp-in-the-ssd"},"How to enable FDP in the SSD?"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},"#Delete any pre-exisitng namespaces \nnvme delete-ns /dev/nvme0 -n 1 \n\n#Disable FDP \nnvme set-feature /dev/nvme0 -f 0x1D -c 0 -s nvme get-feature /dev/nvme0 -f 0x1D -H \n\n#Enable FDP \nnvme set-feature /dev/nvme0 -f 0x1D -c 1 -s \n\n#Verify whether FDP has been enabled/disabled\nnvme get-feature /dev/nvme0 -f 0x1D -H \n\n# Get capacity of drive and use it for further calculations \nnvme id-ctrl /dev/nvme0 | grep nvmcap | sed \"s/,//g\" | awk '{print $3/4096}' \n\n# Create namespace. use the capacity values from the above command in --nsze. For e.g. capacity is 459076086 \nnvme create-ns /dev/nvme0 -b 4096 --nsze=459076086 --ncap=459076086 -p 0,1,2,3 -n 4 \n\n#Attach namespace. e.g. NS id = 1, controller id = 0x7 \nnvme attach-ns /dev/nvme0 --namespace-id=1 --controllers=0x7 \n\n# Deallocate \nnvme dsm /dev/nvme0n1 -n 1 -b 459076086\n")),(0,r.mdx)("h3",{id:"how-to-enable-fdp-in-cachelib"},"How to enable FDP in CacheLib?"),(0,r.mdx)("p",null,"To enable Flexible Data Placement (FDP) support in ",(0,r.mdx)("inlineCode",{parentName:"p"},"Device")," layer of Navy, use the following configuration:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"}," navyConfig.setEnableFDP(enableFDP);\n")),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"When set to ",(0,r.mdx)("inlineCode",{parentName:"li"},"true"),", FDP is enabled and the BigHash and BlockCache device writes get segregated within the SSD.")),(0,r.mdx)("p",null,"Apart from enabling FDP explicitly, the steps to setup and run a CacheLib instance remain unchanged."),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"To enable FDP in the CacheBench config file add the following line to the cache_config parameters:")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-cpp"},'  "navyEnableIoUring": true,\n  "navyQDepth": 1,\n  "deviceEnableFDP" : true\n')),(0,r.mdx)("h3",{id:"qemu-fdp-emulation"},"Qemu FDP emulation"),(0,r.mdx)("p",null,"Even if an FDP enabled SSD is unavailable, a hybrid cache instance can be spun up with FDP enabled using a Qemu emulated FDP SSD. This allows for experimentation with an FDP enabled cache but the WAF gains won't be visible because Qemu doesn't emulate the SSD internal operations which lead to write amplification. However, this can be a helpful tool for understanding how to enable FDP in CacheLib and to study other aspects that come with it. To setup a Qemu emulated FDP SSD, follow the steps documented here : ",(0,r.mdx)("a",{parentName:"p",href:"https://qemu-project.gitlab.io/qemu/system/devices/nvme.html#flexible-data-placement"},"Qemu NVMe Emulation"),"."),(0,r.mdx)("h3",{id:"results-with-and-without-fdp"},"Results with and without FDP"),(0,r.mdx)("p",null,"We run experiments using the ",(0,r.mdx)("a",{parentName:"p",href:"/docs/Cache_Library_User_Guides/Cachebench_FB_HW_eval/"},"key-value cache traces")," using a 1.88TB SSD that supports FDP. We observe the following:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"NVM Cache Size of 930GB (50% of the 1.88TB device) and RAM Size 43GB with SOC size set to 4%",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"SSD WAF FDP - 1.03, SSD WAF Non-FDP - 1.22"))),(0,r.mdx)("li",{parentName:"ul"},"NVM Cache Size of 1.88TB (100% of the 1.88TB device) and RAM Size 43GB with SOC size set to 4%",(0,r.mdx)("ul",{parentName:"li"},(0,r.mdx)("li",{parentName:"ul"},"SSD WAF FDP - 1.03, SSD WAF Non-FDP - 3.22"))),(0,r.mdx)("li",{parentName:"ul"},"Further results can be found ",(0,r.mdx)("a",{parentName:"li",href:"https://download.semiconductor.samsung.com/resources/white-paper/FDP_Whitepaper_102423_Final_10130020003525.pdf"},"here."))))}p.isMDXComponent=!0},13964:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/alternate_fdp_navy-c6e6143f97885d6c8fc2c3ddc82e2cb6.png"}}]);