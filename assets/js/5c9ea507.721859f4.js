"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[7106],{3905:function(e,t,a){a.r(t),a.d(t,{MDXContext:function(){return l},MDXProvider:function(){return p},mdx:function(){return f},useMDXComponents:function(){return u},withMDXComponents:function(){return h}});var o=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(){return n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var o in a)Object.prototype.hasOwnProperty.call(a,o)&&(e[o]=a[o])}return e},n.apply(this,arguments)}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,o,r=function(e,t){if(null==e)return{};var a,o,r={},n=Object.keys(e);for(o=0;o<n.length;o++)a=n[o],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(o=0;o<n.length;o++)a=n[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=o.createContext({}),h=function(e){return function(t){var a=u(t.components);return o.createElement(e,n({},t,{components:a}))}},u=function(e){var t=o.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var a=e.components,r=e.mdxType,n=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),h=u(a),p=r,m=h["".concat(i,".").concat(p)]||h[p]||d[p]||n;return a?o.createElement(m,s(s({ref:t},l),{},{components:a})):o.createElement(m,s({ref:t},l))}));function f(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var n=a.length,i=new Array(n);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<n;l++)i[l]=a[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,a)}m.displayName="MDXCreateElement"},92069:function(e,t,a){a.r(t),a.d(t,{assets:function(){return h},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return u}});var o=a(83117),r=a(80102),n=(a(67294),a(3905)),i=["components"],s={id:"Cache_Admin_Overview",title:"Cache Admin Overview"},c=void 0,l={unversionedId:"facebook/Cache_Monitoring/Cache_Admin_Overview",id:"facebook/Cache_Monitoring/Cache_Admin_Overview",title:"Cache Admin Overview",description:"CacheAdmin is a component for monitoring the cache health for CacheLib cache. Its purpose is to fetch cache stats from Cache, and then upload them to ODS or Scuba as appropriate. The code is located in fbcode/cachelib/facebook/admin/. CacheAdmin contains the following components. As you can see, we separate them into roughly three groups per their update interval.",source:"@site/docs/facebook/Cache_Monitoring/Cache_Admin_Overview.md",sourceDirName:"facebook/Cache_Monitoring",slug:"/facebook/Cache_Monitoring/Cache_Admin_Overview",permalink:"/docs/facebook/Cache_Monitoring/Cache_Admin_Overview",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/facebook/Cache_Monitoring/Cache_Admin_Overview.md",tags:[],version:"current",frontMatter:{id:"Cache_Admin_Overview",title:"Cache Admin Overview"}},h={},u=[{value:"Exporter &amp; How Does It Work",id:"exporter--how-does-it-work",level:2},{value:"Allocator Config Exporter",id:"allocator-config-exporter",level:2},{value:"Pool Stats Exporter &amp; AC Stats Exporter",id:"pool-stats-exporter--ac-stats-exporter",level:2},{value:"Item Stats Exporter",id:"item-stats-exporter",level:2},{value:"ODS Stats Exporter",id:"ods-stats-exporter",level:2},{value:"Service Data Exporter",id:"service-data-exporter",level:2}],p={toc:u};function d(e){var t=e.components,s=(0,r.Z)(e,i);return(0,n.mdx)("wrapper",(0,o.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,n.mdx)("p",null,"CacheAdmin is a component for monitoring the cache health for CacheLib cache. Its purpose is to fetch cache stats from Cache, and then upload them to ODS or Scuba as appropriate. The code is located in fbcode/cachelib/facebook/admin/. CacheAdmin contains the following components. As you can see, we separate them into roughly three groups per their update interval."),(0,n.mdx)("p",null,(0,n.mdx)("img",{src:a(26947).Z,width:"3634",height:"878"})),(0,n.mdx)("h2",{id:"exporter--how-does-it-work"},"Exporter & How Does It Work"),(0,n.mdx)("p",null,'Each exporter inherits from DataExporter class. The DataExporter base class takes in a folly::FunctionScheduler, and is expected to schedule the implementation of its \u201cexportData" function on the scheduler. The way we use the exporters in CacheAdmin is to share the same scheduler with all of them. This way, we use only a single thread (one thread per FunctionScheduler) for all of our exporters. Now let\u2019s go over the exporters one by one.'),(0,n.mdx)("h2",{id:"allocator-config-exporter"},"Allocator Config Exporter"),(0,n.mdx)("p",null,"Each cache instance (i.e. CacheAllocator) is created with a CacheAllocatorConfig config object. This exporter simply serializes the config object and upload it to scuba. The scuba table name is: cachelib_admin_allocator_config."),(0,n.mdx)("p",null,"This table allows us to examine how cache is configured for a particular host or a service. It\u2019s useful if we need to confirm which hosts/service is using which feature. When we add a new config argument, we must also add it to the serialization method ",(0,n.mdx)("inlineCode",{parentName:"p"},"CacheAllocatorConfig::serialize()"),"."),(0,n.mdx)("h2",{id:"pool-stats-exporter--ac-stats-exporter"},"Pool Stats Exporter & AC Stats Exporter"),(0,n.mdx)("p",null,"Cache can be divided into multiple cache pools for the purpose of resource isolation. Each cache pool has its own set of stats (allocations, evictions, how many bytes are used). This exporter is responsible for aggregating each cache pool\u2019s stats and upload it to scuba. The scuba table name is: cachelib_admin_pool_stats. Each time we add a new stat to a cache pool, we need to make sure to export this in the pool stats exporter."),(0,n.mdx)("p",null,"AC Stats Exporter is similar to Pool Stats Exporter but is responsible for aggregating stats across allocation classes within a single cache pool. This is one of the most useful stats exporter as the stats here can reveal a lot when debugging issues. The scuba table name is: cachelib_admin_ac_stats. Each time we add a new stat to an allocation class, we need to make sure to export this in the ac stats exporter."),(0,n.mdx)("p",null,'For a detailed break down on what stats we export. Refer to "Monitoring cache health":'),(0,n.mdx)("ul",null,(0,n.mdx)("li",{parentName:"ul"},(0,n.mdx)("a",{parentName:"li",href:"monitoring/#cachelib-admin-pool-stat"},"Pool stats")),(0,n.mdx)("li",{parentName:"ul"},(0,n.mdx)("a",{parentName:"li",href:"monitoring/#cachelib-admin-ac-stats"},"AC stats"))),(0,n.mdx)("h2",{id:"item-stats-exporter"},"Item Stats Exporter"),(0,n.mdx)("p",null,"We offer two variants here. One is always initialized: \u201cdefault item stats exporter\u201d. This will upload basic item stats (cache key, size, is it a chained item, etc.) to a cachelib-owned scuba table: cachelib_admin_items_stats. In addition, we allow the user to create their custom callback to parse a cachelib item, and also to specify their own scuba table. We do not use logger but instead directly write to scuba as it\u2019s simpler system for us to work with."),(0,n.mdx)("p",null,"Enable custom item stats"),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre",className:"language-cpp"},"enableItemStatsSampling(\n    const AllocatorT& allocator /* unused */,\n    const std::string& scubaTable,\n    const std::function<rfe::ScubaDataSample(typename AllocatorT::Item&)>& cb);\n")),(0,n.mdx)("h2",{id:"ods-stats-exporter"},"ODS Stats Exporter"),(0,n.mdx)("p",null,"This exporter exports only a few stats. They\u2019re stats that describe all the machines running cachelib. We have version stats that describe the allocator version, and the ram and nvm format versions. Allocator version is useful when we add a new feature and would like to know how many hosts has this new feature been rolled out (we bump it on adding such a new feature). Format version is when we make a format change that requires a cold roll."),(0,n.mdx)("p",null,"We also have stats that describe the number of servers running cachelib, how much memory and nvm are managed by cachelib across facebook."),(0,n.mdx)("p",null,"We usually don\u2019t need to change this much. Only change it if we want a new stat that captures something across all the hosts running cachelib."),(0,n.mdx)("h2",{id:"service-data-exporter"},"Service Data Exporter"),(0,n.mdx)("p",null,"This exporter also uploads to ODS. The difference from the \u201cODS stats exporter\u201d is that this exporter is responsible for all stats for a particular \u201ccache name\u201d. Typically each cache use case has its own unique cache name. We upload stats that describe the entire cache (hit rate, mem size, number of items, number of lookups into flash, etc.). Add any stats here if you want to see it reflected in real time on ODS."))}d.isMDXComponent=!0},26947:function(e,t,a){t.Z=a.p+"assets/images/cache_admin_overview-b6a708e1a7133964f1ede533534c00e8.png"}}]);