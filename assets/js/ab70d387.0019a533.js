"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[4535],{15680:(e,t,a)=>{a.r(t),a.d(t,{MDXContext:()=>c,MDXProvider:()=>u,mdx:()=>y,useMDXComponents:()=>m,withMDXComponents:()=>d});var o=a(96540);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var o in a)Object.prototype.hasOwnProperty.call(a,o)&&(e[o]=a[o])}return e},i.apply(this,arguments)}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,o,n=function(e,t){if(null==e)return{};var a,o,n={},i=Object.keys(e);for(o=0;o<i.length;o++)a=i[o],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)a=i[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=o.createContext({}),d=function(e){return function(t){var a=m(t.components);return o.createElement(e,i({},t,{components:a}))}},m=function(e){var t=o.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=m(e.components);return o.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=m(a),u=n,p=d["".concat(r,".").concat(u)]||d[u]||h[u]||i;return a?o.createElement(p,s(s({ref:t},c),{},{components:a})):o.createElement(p,s({ref:t},c))}));function y(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,r=new Array(i);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,r[1]=s;for(var c=2;c<i;c++)r[c]=a[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,a)}p.displayName="MDXCreateElement"},17870:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>m});var o=a(9668),n=a(21367),i=(a(96540),a(15680)),r=["components"],s={id:"faq",title:"FAQ"},l=void 0,c={unversionedId:"Cache_Library_User_Guides/faq",id:"Cache_Library_User_Guides/faq",title:"FAQ",description:"My cache instance is broken. Help!",source:"@site/docs/Cache_Library_User_Guides/faq.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/faq",permalink:"/docs/Cache_Library_User_Guides/faq",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/faq.md",tags:[],version:"current",frontMatter:{id:"faq",title:"FAQ"},sidebar:"userguideSidebar",previous:{title:"Visit data in cache",permalink:"/docs/Cache_Library_User_Guides/Visit_data_in_cache"},next:{title:"Item and Handle",permalink:"/docs/Cache_Library_User_Guides/Item_and_Handle"}},d={},m=[{value:"My cache instance is broken. Help!",id:"my-cache-instance-is-broken-help",level:2},{value:"Why my cache is not persisted after process restart?",id:"why-my-cache-is-not-persisted-after-process-restart",level:3},{value:"Why do I see allocation failures?",id:"why-do-i-see-allocation-failures",level:3},{value:"Why do I see invalid allocs?",id:"why-do-i-see-invalid-allocs",level:3},{value:"Why is my cache so slow?",id:"why-is-my-cache-so-slow",level:3},{value:"My application crashed. It takes forever to core dump.",id:"my-application-crashed-it-takes-forever-to-core-dump",level:3},{value:"I update certain items in my cache frequently (from some refill logic), but I do not want them to be seen as hotter than other items in my cache which are updated less frequently but read just as frequently. What can I do?",id:"i-update-certain-items-in-my-cache-frequently-from-some-refill-logic-but-i-do-not-want-them-to-be-seen-as-hotter-than-other-items-in-my-cache-which-are-updated-less-frequently-but-read-just-as-frequently-what-can-i-do",level:3},{value:"How do I use an item?",id:"how-do-i-use-an-item",level:3},{value:"How much space does my item take?",id:"how-much-space-does-my-item-take",level:3},{value:"How does eviction work?",id:"how-does-eviction-work",level:3},{value:"What is slab rebalancing (and pool rebalancing, and pool resizing)?",id:"what-is-slab-rebalancing-and-pool-rebalancing-and-pool-resizing",level:3},{value:"What does the term mean?",id:"what-does-the-term-mean",level:3}],u={toc:m};function h(e){var t=e.components,a=(0,n.A)(e,r);return(0,i.mdx)("wrapper",(0,o.A)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("h2",{id:"my-cache-instance-is-broken-help"},"My cache instance is broken. Help!"),(0,i.mdx)("h3",{id:"why-my-cache-is-not-persisted-after-process-restart"},"Why my cache is not persisted after process restart?"),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Did your service used to recover cache fine? But it didn't recover in the newest release?")),(0,i.mdx)("p",null,"This could be due to cachelib's Format Version changes. In the event of a cache format change, CacheLib Cache cannot persist its cache content across service upgrades."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Did you call ",(0,i.mdx)("inlineCode",{parentName:"strong"},"CacheAllocator::shutDown()")," explicitly?")),(0,i.mdx)("p",null,"CacheAllocator will destroy all shared memory segments if shutDown is not called before the object is destroyed."),(0,i.mdx)("h3",{id:"why-do-i-see-allocation-failures"},"Why do I see allocation failures?"),(0,i.mdx)("p",null,"It is normal to see some allocation failures over the lifetime of your cache. However this number should be very low (e.g., less than 0.001% of your allocation attempts). If the rate is high, it can be caused by the following:"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"You do not have any free slabs in certain allocation classes. To remedy this, you must enable slab rebalancing with the default policy (just ",(0,i.mdx)("inlineCode",{parentName:"li"},"RebalancePolicy")," by itself). This will rebalance your memory according to the allocation failures."),(0,i.mdx)("li",{parentName:"ol"},"You have very high number of allocation attempts and very low number of slabs in certain allocation classes (think 10K/s and only one or two slabs). Hence rate of evictions cannot keep up with the rate of allocations. To remedy this, you can enable ",(0,i.mdx)("inlineCode",{parentName:"li"},"LruTailAge")," rebalance policy which would try to keep all allocation classes around similar eviction age.")),(0,i.mdx)("h3",{id:"why-do-i-see-invalid-allocs"},"Why do I see invalid allocs?"),(0,i.mdx)("p",null,"You're questing for allocation size that is bigger than the biggest allocation size your cache allows. Please check if you're customizing allocation class sizes and the biggest class size you've set. If you're not customizing them, then this means the size your item (size of key + size of value + 32 bytes) is bigger than 4 MB, which is the upper bound of what we allow into our cache. If you absolutely need to store such big values, use ",(0,i.mdx)("a",{parentName:"p",href:"chained_items"},"chained items"),"."),(0,i.mdx)("h3",{id:"why-is-my-cache-so-slow"},"Why is my cache so slow?"),(0,i.mdx)("p",null,"Have you checked how your hash table is configured? In general the hash table size should be configured to be at least 1.5 times of the number of items you have in cache."),(0,i.mdx)("h3",{id:"my-application-crashed-it-takes-forever-to-core-dump"},"My application crashed. It takes forever to core dump."),(0,i.mdx)("p",null,"If you're using a cache that's tens of GB or more, it will take a while to finish dumping the core because it's so big. You can turn off dumping core for cache memory by passing in ",(0,i.mdx)("inlineCode",{parentName:"p"},"false")," to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"setFullCoredump()")," method when you set up the cache. Beware that turning off core dump for cache memory means it will be near impossible to debug any buffer-overflow or use-after-free bugs in cache memory."),(0,i.mdx)("h3",{id:"i-update-certain-items-in-my-cache-frequently-from-some-refill-logic-but-i-do-not-want-them-to-be-seen-as-hotter-than-other-items-in-my-cache-which-are-updated-less-frequently-but-read-just-as-frequently-what-can-i-do"},"I update certain items in my cache frequently (from some refill logic), but I do not want them to be seen as hotter than other items in my cache which are updated less frequently but read just as frequently. What can I do?"),(0,i.mdx)("p",null,"You can configure LRU (or any other eviction policies you're using) to only promote for reads."),(0,i.mdx)("h3",{id:"how-do-i-use-an-item"},"How do I use an item?"),(0,i.mdx)("p",null,"Each item has a key and an value associated with it. Both the key and the value can be a string or a POD or anything that's memcpy-safe:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-cpp"},'auto myHandle = cache->find("I can find my item by using a key");\nfolly::StringPiece myString{myHandle.getMemory(), myHandle.getSize()};\nstd::cout << myString << std::endl;\n')),(0,i.mdx)("p",null,"An item can also be looked up and used as a user-defined type:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-cpp"},'struct MyStructure {\n  bool aBooleanField;\n  uint64_t[10] someIds;\n};\n\nauto myHandle = cache->find("I can find my item by using a key");\nauto myStruct = myHandle->getMemoryAs<MyStructure>();\n\nif (myStruct->aBooleanField == true) {\n  myStruct->someIds[5] == 7777777;\n}\n')),(0,i.mdx)("h3",{id:"how-much-space-does-my-item-take"},"How much space does my item take?"),(0,i.mdx)("p",null,"When you cache an item, it takes more space than just the number of bytes you intend to cache. That is, if you're trying to cache a structure ",(0,i.mdx)("inlineCode",{parentName:"p"},"Foo")," with a key ",(0,i.mdx)("inlineCode",{parentName:"p"},'"HelloKeyForFoo"'),", the space required will be bigger or equal to ",(0,i.mdx)("inlineCode",{parentName:"p"},'sizeof(CacheType::Item) + sizeof("HelloKeyForFoo") + sizeof(Foo)'),"."),(0,i.mdx)("p",null,"The reason the size is at least equal to the above should be obvious. We need space for not just ",(0,i.mdx)("inlineCode",{parentName:"p"},"Foo")," but also its key. We also need some additional space for the item header, which contains book-keeping information such as flags and references (yes, internally each item is ref-counted, quite similar to how one would implement a shared pointer)."),(0,i.mdx)("p",null,"However, it may not be immediately obvious that sometimes your item can take up more space than it needs. This is because the memory allocator in cachelib does not give true variable sized allocations (not many do). Cachelib's memory allocator can be configured to support from 1 to 127 different allocation sizes (from a minimum of 64 bytes to a maximum of 4 MB). And when you request for N bytes, we will pick the smallest allocation size that will fit the entire space your item needs."),(0,i.mdx)("h3",{id:"how-does-eviction-work"},"How does eviction work?"),(0,i.mdx)("p",null,"See ",(0,i.mdx)("a",{parentName:"p",href:"eviction_policy"},"Eviction Policy"),"."),(0,i.mdx)("h3",{id:"what-is-slab-rebalancing-and-pool-rebalancing-and-pool-resizing"},"What is slab rebalancing (and pool rebalancing, and pool resizing)?"),(0,i.mdx)("p",null,"See ",(0,i.mdx)("a",{parentName:"p",href:"pool_rebalance_strategy"},"Pool Rebalance Strategy"),"."),(0,i.mdx)("h3",{id:"what-does-the-term-mean"},"What does the term mean?"),(0,i.mdx)("p",null,"See ",(0,i.mdx)("a",{parentName:"p",href:"terms"},"Cache Library terminology"),"."))}h.isMDXComponent=!0}}]);