"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[2921],{3905:function(e,t,n){n.r(t),n.d(t,{MDXContext:function(){return l},MDXProvider:function(){return u},mdx:function(){return f},useMDXComponents:function(){return s},withMDXComponents:function(){return d}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},o.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function m(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){return function(t){var n=s(t.components);return r.createElement(e,o({},t,{components:n}))}},s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,l=m(e,["components","mdxType","originalType","parentName"]),d=s(n),u=a,h=d["".concat(i,".").concat(u)]||d[u]||p[u]||o;return n?r.createElement(h,c(c({ref:t},l),{},{components:n})):r.createElement(h,c({ref:t},l))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var c={};for(var m in t)hasOwnProperty.call(t,m)&&(c[m]=t[m]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},19209:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return m},default:function(){return p},frontMatter:function(){return c},metadata:function(){return l},toc:function(){return s}});var r=n(83117),a=n(80102),o=(n(67294),n(3905)),i=["components"],c={id:"Item_Destructor",title:"Item Destructor"},m=void 0,l={unversionedId:"Cache_Library_User_Guides/Item_Destructor",id:"Cache_Library_User_Guides/Item_Destructor",title:"Item Destructor",description:"Introduction",source:"@site/docs/Cache_Library_User_Guides/Item_Destructor.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/Item_Destructor",permalink:"/docs/Cache_Library_User_Guides/Item_Destructor",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/Item_Destructor.md",tags:[],version:"current",frontMatter:{id:"Item_Destructor",title:"Item Destructor"},sidebar:"userguideSidebar",previous:{title:"Configure lookup performance",permalink:"/docs/Cache_Library_User_Guides/Configure_HashTable"},next:{title:"Remove callback",permalink:"/docs/Cache_Library_User_Guides/Remove_callback"}},d={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Example",id:"example",level:2},{value:"DestructorData",id:"destructordata",level:2},{value:"Guarantees",id:"guarantees",level:2},{value:"Performance Impact",id:"performance-impact",level:2},{value:"Migrate from RemoveCallback",id:"migrate-from-removecallback",level:2},{value:"<strong>Known Issue</strong>",id:"known-issue",level:2}],u={toc:s};function p(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.mdx)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("h2",{id:"introduction"},"Introduction"),(0,o.mdx)("p",null,(0,o.mdx)("em",{parentName:"p"},"Item Destructor")," provides destructor semantics for an item in the cache. This\nis useful when you want to execute some logic on removal of an item from the\ncache. When you use cachelib APIs to concurrently allocate memory from the\ncache for an item, insert an item into the cache, or remove an item from the\ncache, the item's lifetime ends when the item is evicted or removed from the\ncache and the last handle held by all sources drops. ",(0,o.mdx)("em",{parentName:"p"},"Item Destructor")," provides\nyou an ability to capture this and take some appropriate action if needed."),(0,o.mdx)("p",null,(0,o.mdx)("em",{parentName:"p"},"Item Destructor")," is an extension to\n",(0,o.mdx)("a",{parentName:"p",href:"Remove_callback"},"Remove callback"),", it guarantees\nthat the destructor is executed ",(0,o.mdx)("strong",{parentName:"p"},"once and only once")," when the item is dropped\nfrom the cache, includes ",(0,o.mdx)("strong",{parentName:"p"},"both DRAM and NVM"),". If Nvm Cache is not enabled,\n",(0,o.mdx)("em",{parentName:"p"},"Item Destructor")," does the exact same behavior as ",(0,o.mdx)("em",{parentName:"p"},"Remove Callback"),". These two\nfeatures can't be used at the same time."),(0,o.mdx)("h2",{id:"example"},"Example"),(0,o.mdx)("p",null,"For example, suppose you want to maintain a counter for the total number of\nitems in your cache and increment the counter when you call the\n",(0,o.mdx)("inlineCode",{parentName:"p"},"insertOrReplace()")," method. The item you inserted could be evicted or removed\nfrom the cache when you again call ",(0,o.mdx)("inlineCode",{parentName:"p"},"insertOrReplace()")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"allocate()"),". To\ndecrement the counter when the item you inserted is evicted or removed by\nanother thread, you can have your logic encapsulated as i",(0,o.mdx)("em",{parentName:"p"},"tem destructor")," ."),(0,o.mdx)("p",null,(0,o.mdx)("em",{parentName:"p"},"Item Destructor")," takes the following signature and can be provided in the\nconfig for initializing the cache:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},"auto itemDestructor = [&](const Allocator::DestructorData& data) { --totalItems; };\nconfig.setItemDestructor(itemDestructor);\n// Adds an item to cache and increment the counter.\nvoid addToCache(std::string key, size_t val) {\n  auto handle = cache.allocate(keys[i], 100); // allocate an item\n  cache.insertOrReplace(handle); // insert into cache.\n  ++totalItems;\n}\n// Suppose your cache can contain at most 5 items and\n// it evicts beyond that.\nfor (int i = 0; i < 1000; i++) {\n  addToCache(std::to_string(i), 100);\n}\nstd::cout << totalItems << std::endl; // this will print 5.\n")),(0,o.mdx)("h2",{id:"destructordata"},"DestructorData"),(0,o.mdx)("p",null,(0,o.mdx)("em",{parentName:"p"},"Item Destructor")," gets called with the following pieces of information:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-cpp"},"// used by ItemDestructor, indicating how the item is destructed\nenum class DestructorContext {\n  // item was in dram and evicted from dram. it could have\n  // been present in nvm as well.\n  kEvictedFromRAM,\n\n  // item was only in nvm and evicted from nvm\n  kEvictedFromNVM,\n\n  // item was present in dram and removed by user calling\n  // remove()/insertOrReplace(), or removed due to expired.\n  // it could have been present in nvm as well.\n  kRemovedFromRAM,\n\n  // item was present only in nvm and removed by user calling\n  // remove()/insertOrReplace().\n  kRemovedFromNVM\n};\n\nstruct DestructorData {\n  // remove or eviction\n  DestructorContext context;\n\n  // item about to be freed back to allocator\n  // when the item is evicted/removed from NVM, the item is created on the\n  // heap, functions (e.g. CacheAllocator::getAllocInfo) that assumes item is\n  // located in cache slab doesn't work in such case.\n  // chained items must be iterated though @chainedAllocs\n  // internal APIs getNext and getParentItem are broken for\n  // items destructed from NVM.\n  Item& item;\n\n  // Iterator range pointing to chained allocs associated with @item\n  // when chained items are evicted/removed from NVM, items are created on the\n  // heap, functions (e.g. CacheAllocator::getAllocInfo) that assumes items\n  // are located in cache slab doesn't work in such case.\n  folly::Range<ChainedItemIter> chainedAllocs;\n};\n")),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("inlineCode",{parentName:"p"},"context"),"\nThis refers to the context of removal. ",(0,o.mdx)("inlineCode",{parentName:"p"},"ItemDestructor")," can be called ","[invoked]","\non an item when it is explicitly removed by the user through the ",(0,o.mdx)("inlineCode",{parentName:"p"},"remove()")," API\nor when it is replacing an old item through the ",(0,o.mdx)("inlineCode",{parentName:"p"},"insertOrReplace()")," API, or\nwhen it being evicted to make room for a new item. For the first two calls on\n",(0,o.mdx)("inlineCode",{parentName:"p"},"ItemDestructor"),", the context is ",(0,o.mdx)("inlineCode",{parentName:"p"},"kRemovedFromRAM"),"or ",(0,o.mdx)("inlineCode",{parentName:"p"},"kRemovedFromNVM")," depends\non the last location of the item; and for eviction, the context is\n",(0,o.mdx)("inlineCode",{parentName:"p"},"kEvictedFromRAM")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"kEvictedFromNVM"),".")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("inlineCode",{parentName:"p"},"item")," Reference to the item that is being\ndestroyed. Modifying the item at this point is pointless because this is the\nlast handle to the item and the memory will be recycled after the call to the\ndestructor.When the item is evicted/removed from NVM, the item is created on\nthe heap, functions (e.g. CacheAllocator::getAllocInfo) that assumes item is\nlocated in cache slab doesn't work in such case.")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("p",{parentName:"li"},(0,o.mdx)("inlineCode",{parentName:"p"},"chainedAllocs")," This provides a reference to\nthe list of chained items associated with the given item if they exist. For\ndetails on what chained allocations are, see\n[","[Cache_Library_User_Guides/Visit_data_in_cache/ | visit data in\ncache]","].Chained items must be iterated though ",(0,o.mdx)("inlineCode",{parentName:"p"},"chainedAllocs"),", internal APIs\n",(0,o.mdx)("inlineCode",{parentName:"p"},"getNext")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"getParentItem")," are broken for items destructed from NVM."))),(0,o.mdx)("h2",{id:"guarantees"},"Guarantees"),(0,o.mdx)("p",null,"Cachelib guarantees the following for ",(0,o.mdx)("em",{parentName:"p"},"Item Destructor")," executions:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The destructor will be executed ",(0,o.mdx)("em",{parentName:"li"},"exactly once")," when the last handle for the\nitem goes out of scope and the item is no longer accessible through the cache\nupon calling ",(0,o.mdx)("inlineCode",{parentName:"li"},"remove()")," or ",(0,o.mdx)("inlineCode",{parentName:"li"},"insertOrReplace()")," causing a replacement."),(0,o.mdx)("li",{parentName:"ul"},"The destructor will be executed for any item that is evicted from cache."),(0,o.mdx)("li",{parentName:"ul"},"When the destructor is executed, there can be no other future or concurrent accessors to the item."),(0,o.mdx)("li",{parentName:"ul"},"The destructor will ",(0,o.mdx)("em",{parentName:"li"},"not")," be executed when item is in-place mutated,\nincluding add/pop chained items, and value mutation via ",(0,o.mdx)("inlineCode",{parentName:"li"},"getMemory()"),"."),(0,o.mdx)("li",{parentName:"ul"},"The destructor will ",(0,o.mdx)("em",{parentName:"li"},"not")," be executed if you allocate memory for an item and\ndon't insert the item into the cache."),(0,o.mdx)("li",{parentName:"ul"},"The destructor will ",(0,o.mdx)("em",{parentName:"li"},"not")," be executed when items are moved internally.")),(0,o.mdx)("p",null,"Note that ",(0,o.mdx)("em",{parentName:"p"},"Item Destructor")," is executed per item, not per key. For example, if\nyou already have an item in cache and call ",(0,o.mdx)("inlineCode",{parentName:"p"},"insertOrReplace()")," to replace it\nwith another item with same key (even same value), cachelib will execute the\ndestructor for the replaced item."),(0,o.mdx)("h2",{id:"performance-impact"},"Performance Impact"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},"One lock is added to protect against race conditions for concurrent\noperations, but the lock is sharded and performance impact is minimal."),(0,o.mdx)("li",{parentName:"ol"},"Additional flash read is done in BlockCache in order to execute the\ndestructor, it will be retried if the region is being reclaimed, and fail to\nread (e.g. io error) will disable Nvm Cache.")),(0,o.mdx)("h2",{id:"migrate-from-removecallback"},"Migrate from RemoveCallback"),(0,o.mdx)("p",null,"The migration is very simple:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("inlineCode",{parentName:"li"},"config.setRemoveCallback")," -> ",(0,o.mdx)("inlineCode",{parentName:"li"},"config.setItemDestructor")),(0,o.mdx)("li",{parentName:"ol"},"Update your callback parameter ",(0,o.mdx)("inlineCode",{parentName:"li"},"RemoveCbData")," -> ",(0,o.mdx)("inlineCode",{parentName:"li"},"DestructorData"),", and the context."),(0,o.mdx)("li",{parentName:"ol"},"Make sure chained items are iterated though ",(0,o.mdx)("inlineCode",{parentName:"li"},"chainedAllocs"),".")),(0,o.mdx)("p",null,"The impact to you:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"If you only use DRAM cache, no impact, both functionality and performance are same."),(0,o.mdx)("li",{parentName:"ul"},"If you're using hybrid cache, the callback will only be triggered when\nitem kicked off from the whole cache, and there is some performance impact but\nit should be minimal (see 'Performance Impact' section for\ndetails).")),(0,o.mdx)("h2",{id:"known-issue"},(0,o.mdx)("strong",{parentName:"h2"},"Known Issue")),(0,o.mdx)("p",null,"We try our best to guarantee that the destructor is triggered once and only\nonce for each item, but there is one scenario which the destructor would not be\nexecuted: if we get a reference overflow exception when an item is evicted or\nremoved from NvmCache. This scenario should happen very rare,\n",(0,o.mdx)("inlineCode",{parentName:"p"},"nvm.destructors.refcount_overflow")," stat can be used to track if this has ever\nhappened."))}p.isMDXComponent=!0}}]);