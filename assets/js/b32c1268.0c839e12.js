"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[756],{3905:function(e,n,a){a.r(n),a.d(n,{MDXContext:function(){return l},MDXProvider:function(){return m},mdx:function(){return f},useMDXComponents:function(){return h},withMDXComponents:function(){return d}});var r=a(67294);function t(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e},i.apply(this,arguments)}function c(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?c(Object(a),!0).forEach((function(n){t(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):c(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function o(e,n){if(null==e)return{};var a,r,t=function(e,n){if(null==e)return{};var a,r,t={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var l=r.createContext({}),d=function(e){return function(n){var a=h(n.components);return r.createElement(e,i({},n,{components:a}))}},h=function(e){var n=r.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):s(s({},n),e)),a},m=function(e){var n=h(e.components);return r.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var a=e.components,t=e.mdxType,i=e.originalType,c=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),d=h(a),m=t,p=d["".concat(c,".").concat(m)]||d[m]||u[m]||i;return a?r.createElement(p,s(s({ref:n},l),{},{components:a})):r.createElement(p,s({ref:n},l))}));function f(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var i=a.length,c=new Array(i);c[0]=p;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s.mdxType="string"==typeof e?e:t,c[1]=s;for(var l=2;l<i;l++)c[l]=a[l];return r.createElement.apply(null,c)}return r.createElement.apply(null,a)}p.displayName="MDXCreateElement"},2957:function(e,n,a){a.r(n),a.d(n,{assets:function(){return d},contentTitle:function(){return o},default:function(){return u},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return h}});var r=a(83117),t=a(80102),i=(a(67294),a(3905)),c=["components"],s={id:"Cross_Host_Cache_Persistence",title:"Cross Host Cache Persistence"},o=void 0,l={unversionedId:"Cache_Library_User_Guides/Cross_Host_Cache_Persistence",id:"Cache_Library_User_Guides/Cross_Host_Cache_Persistence",title:"Cross Host Cache Persistence",description:"Cachelib supports persisting the cache into a remote storage and restoring in a",source:"@site/docs/Cache_Library_User_Guides/Cross_Host_Cache_Persistence.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/Cross_Host_Cache_Persistence",permalink:"/docs/Cache_Library_User_Guides/Cross_Host_Cache_Persistence",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/Cross_Host_Cache_Persistence.md",tags:[],version:"current",frontMatter:{id:"Cross_Host_Cache_Persistence",title:"Cross Host Cache Persistence"},sidebar:"userguideSidebar",previous:{title:"Cache persistence",permalink:"/docs/Cache_Library_User_Guides/Cache_persistence"},next:{title:"TTL Reaper",permalink:"/docs/Cache_Library_User_Guides/ttl_reaper"}},d={},h=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Implement Stream Reader and Writer APIs",id:"implement-stream-reader-and-writer-apis",level:2},{value:"Persist the Cache",id:"persist-the-cache",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Restore the Cache",id:"restore-the-cache",level:2},{value:"Error Handling",id:"error-handling-1",level:3},{value:"Incompatible Config Changes across Restarts (both same host or x-host)",id:"incompatible-config-changes-across-restarts-both-same-host-or-x-host",level:3},{value:"Simple Example",id:"simple-example",level:2},{value:"Stream APIs",id:"stream-apis",level:3},{value:"Persist Cache",id:"persist-cache",level:3},{value:"Restore Cache",id:"restore-cache",level:3}],m={toc:h};function u(e){var n=e.components,a=(0,t.Z)(e,c);return(0,i.mdx)("wrapper",(0,r.Z)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"Cachelib supports persisting the cache into a remote storage and restoring in a\ndifferent machine (so called cross host persistence). This is an enhancement to\n",(0,i.mdx)("a",{parentName:"p",href:"Cache_persistence"},"Cache Persistence\nfeature"),",\nwhich persist the cache in the same machine across restarts. This is useful\nwhen binary is started on a different machine without losing cache data in the\nshared infra, but this is not a persistent storage that serves like databases."),(0,i.mdx)("h2",{id:"prerequisites"},"Prerequisites"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"Create a persistence cache with ",(0,i.mdx)("a",{parentName:"li",href:"Cache_persistence"},"Cache Persistence")," user guide."),(0,i.mdx)("li",{parentName:"ol"},"Shutdown cache successfully."),(0,i.mdx)("li",{parentName:"ol"},"Only POSIX is supported."),(0,i.mdx)("li",{parentName:"ol"},"Only default PageSize is supported.")),(0,i.mdx)("h2",{id:"implement-stream-reader-and-writer-apis"},"Implement Stream Reader and Writer APIs"),(0,i.mdx)("p",null,"To persist the cache, shutdown cache first, instantiate PersistenceManager with\nthe cache config, call saveCache function and pass in a writer. To restore a\ncache,  instantiate PersistenceManager with the same cache config, call\nrestoreCache function and pass in a read, then create cache with\n",(0,i.mdx)("inlineCode",{parentName:"p"},"SharedMemAttach"),"."),(0,i.mdx)("p",null,"The reader and writer interfaces are defined in PersistenceManager, users need\nto implement the APIs with their own choice of backend storage, e.g. Manifold,\nS3, and NAS."),(0,i.mdx)("p",null,"The interfaces are defined as"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-cpp"},"namespace facebook::cachelib::persistence {\n/**\n * Stream reader and writer APIs for PersistenceManager use.\n * read/write functions are called in a single thread.\n * Users should implement read/write functions with their\n * own storage backend, e.g. file, manifold, AWS.\n * Users should throw exception if any error happens during read/write,\n * exceptions are not handled by PersistenceManager so users should catch\n * and handle them properly.\n */\nclass PersistenceStreamReader {\n public:\n  virtual ~PersistenceStreamReader() {}\n  // data in IOBuf must remain valid until next read call,\n  // it is recommanded to make IObuf maintain the lifetime of data.\n  // the IObuf can't be chained.\n  virtual folly::IOBuf read(size_t length) = 0;\n  virtual char read() = 0;\n};\nclass PersistenceStreamWriter {\n public:\n  virtual ~PersistenceStreamWriter() {}\n  // PersistenceManager guarantees the data in IOBuf\n  // remain valid until flush() is called.\n  // The implementation can save the IOBuf (e.g. add to IOBufQueue) here,\n  // but the data must be either copied out or sent to remote storage\n  // when flush() is called, data in IOBuf might be invalid after that.\n  virtual void write(folly::IOBuf buffer) = 0;\n  virtual void write(char c) = 0;\n  virtual void flush() = 0;\n};\n}\n")),(0,i.mdx)("p",null,"Functions will be called in a single thread, and exceptions are expected to be\nthrown in case of any error happens inside the functions. PersistenceManager\nwill serialize the data and stream to ",(0,i.mdx)("inlineCode",{parentName:"p"},"PersistenceStreamWriter")," during\npersistence, it is recommended to buffer the data and flush to remote storage\nin larger chunks, for example ",(0,i.mdx)("inlineCode",{parentName:"p"},"PersistenceManagerWriter")," could read a 1MB\npayload from each ",(0,i.mdx)("inlineCode",{parentName:"p"},"write")," call, but internally buffers to a 16MB chunk before\nflushing to manifold. On restoring, PersistenceManager will rely on the data\nprovided by ",(0,i.mdx)("inlineCode",{parentName:"p"},"PersistenceStreamReader"),", it will only fetch certain size of data\neach time so prefetch a large chunk of data is preferred for better\nperformance, e.g. the  ",(0,i.mdx)("inlineCode",{parentName:"p"},"PersistenceStreamReader")," can download 16MB data chunk\nfrom Manifold and return a small portion for each ",(0,i.mdx)("inlineCode",{parentName:"p"},"read")," call."),(0,i.mdx)("h2",{id:"persist-the-cache"},"Persist the Cache"),(0,i.mdx)("p",null,"To persist the cache to a remote storage, construct ",(0,i.mdx)("inlineCode",{parentName:"p"},"PersistenceManger")," with\nCacheLibConfig, and call ",(0,i.mdx)("inlineCode",{parentName:"p"},"saveCache")," function with user's writer\nimplementation. Cache config (currently cache name only) is persisted for\nvalidation purpose, cache metadata, cache data in RAM and Navy are persisted to\nrestore the cache instance on the different machine."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/persistence/PersistenceManager.h"\nusing namespace facebook::cachelib;\n\n// Cache::Config config;\n// Create cache with ShareMemNew or SharedMemAttach\n// cache.shutdown();\nYourWriterImplementation writer;\npersistence::PersistenceManager manager(config);\nmanager.saveCache(writer);\n')),(0,i.mdx)("h3",{id:"error-handling"},"Error Handling"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"Errors and exceptions raised by Writer's function are not handled by\nPersistenceManger, so users should catch and handle properly."),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("inlineCode",{parentName:"li"},"std::invalid_argument")," will be thrown if there is any error with the cache\nconfig or cache instance during ",(0,i.mdx)("inlineCode",{parentName:"li"},"saveCache"),"."),(0,i.mdx)("li",{parentName:"ol"},"Persistence can be retried upon any error, cache instance is not changed\nduring ",(0,i.mdx)("inlineCode",{parentName:"li"},"saveCache"),".")),(0,i.mdx)("h2",{id:"restore-the-cache"},"Restore the Cache"),(0,i.mdx)("p",null,"To restore the cache from a remote storage, construct ",(0,i.mdx)("inlineCode",{parentName:"p"},"PersistenceManger")," with\nCacheLibConfig, and call ",(0,i.mdx)("inlineCode",{parentName:"p"},"restoreCache")," function with user's reader\nimplementation. Cache config should be compatible with the one provided for\npersistence, and the reader should return exact same data as what is written to\nwriter during persistence."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/persistence/PersistenceManager.h"\nusing namespace facebook::cachelib;\n\n// Cache::Config config;\nYourReaderImplementation reader;\npersistence::PersistenceManager manager(config);\nmanager.restoreCache(reader);\n// Create cache with SharedMemAttach\n')),(0,i.mdx)("h3",{id:"error-handling-1"},"Error Handling"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"Errors and exceptions raised by Writer's function are not handled by\nPersistenceManger, so users should catch and handle properly."),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("inlineCode",{parentName:"li"},"std::invalid_argument")," will be thrown if there is any error during\n",(0,i.mdx)("inlineCode",{parentName:"li"},"restoreCache")," , includes version mismatch, invalid data returned from reader,\nwrong config provide (different cache name), etc."),(0,i.mdx)("li",{parentName:"ol"},"Persistence version is required to be matched, while cache version mismatch\nis only warning at the restore stage, compatibility check and migration is\nhandled in cache attachment."),(0,i.mdx)("li",{parentName:"ol"},"By calling ",(0,i.mdx)("inlineCode",{parentName:"li"},"restoreCache")," any existing cachelib data/metadata will be\nerased, and will not be recovered on any failure."),(0,i.mdx)("li",{parentName:"ol"},"Attachment after restore might fail if the supplied cachelib config is\nincompatible with the config of the restored cache content, or cache version is\nincompatible.")),(0,i.mdx)("h3",{id:"incompatible-config-changes-across-restarts-both-same-host-or-x-host"},"Incompatible Config Changes across Restarts (both same host or x-host)"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"cacheSize"),(0,i.mdx)("li",{parentName:"ol"},"cacheName"),(0,i.mdx)("li",{parentName:"ol"},"usePosixForShm"),(0,i.mdx)("li",{parentName:"ol"},"isCompactCache"),(0,i.mdx)("li",{parentName:"ol"},"isNvmCacheEncryption"),(0,i.mdx)("li",{parentName:"ol"},"isNvmCacheTruncateAllocSize"),(0,i.mdx)("li",{parentName:"ol"},"accessConfig.numBuckets"),(0,i.mdx)("li",{parentName:"ol"},"accessConfig.pageSize"),(0,i.mdx)("li",{parentName:"ol"},"chainedItemAccessConfig.numBuckets"),(0,i.mdx)("li",{parentName:"ol"},"nvmConfig.navyConfig.getFileName"),(0,i.mdx)("li",{parentName:"ol"},"nvmConfig.navyConfig.getRaidPaths"),(0,i.mdx)("li",{parentName:"ol"},"nvmConfig.navyConfig.getFileSize")),(0,i.mdx)("h2",{id:"simple-example"},"Simple Example"),(0,i.mdx)("h3",{id:"stream-apis"},"Stream APIs"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include <fstream>\n#include "folly/io/IOBufQueue.h"\n#include "folly/io/IOBuf.h"\n#include "cachelib/allocator/CacheAllocator.h"\n#include "cachelib/persistence/PersistenceManager.h"\nusing namespace facebook::cachelib::persistence;\n\nclass FileReader : public PersistenceStreamReader {\n public:\n  FileReader(const std::string& filename) : if_(filename, std::ifstream::in) {\n  }\n\n  ~FileReader() {\n  }\n\n  folly::IOBuf read(size_t length) override {\n    auto buf = folly::IOBuf::create(length);\n    if_.read(reinterpret_cast<char*>(buf->writableData()), length);\n\n    if (!if_.good()) {\n      throw std::invalid_argument("can\'t read more data from file");\n    }\n\n    buf->append(length);\n    return std::move(*buf);\n  }\n\n  char read() override {\n    char c;\n    if (!if_.get(c)) {\n      throw std::invalid_argument("can\'t read more data from file");\n    }\n    return c;\n  }\n private:\n  std::ifstream if_;\n};\n\nclass FileWriter : public PersistenceStreamWriter {\n public:\n  FileWriter(const std::string& filename) : of_(filename, std::ofstream::out) {\n  }\n\n  ~FileWriter() {\n    flush();\n  }\n\n  void write(folly::IOBuf buffer) override {\n    queue_.append(buffer);\n  }\n\n  void write(char c) override {\n    queue_.append(&c, sizeof(bool));\n  }\n\n  void flush() override {\n    auto buf = queue_.move();\n    for (auto& br : *buf) {\n      of_.write(reinterpret_cast<const char*>(br.data()), br.size());\n    }\n    of_.flush();\n  }\n private:\n   std::ofstream of_;\n   folly::IOBufQueue queue_;\n};\n')),(0,i.mdx)("h3",{id:"persist-cache"},"Persist Cache"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/persistence/PersistenceManager.h"\nusing namespace facebook::cachelib;\n\nusing Cache = cachelib::LruAllocator;\nusing CacheConfig = typename Cache::Config;\nusing CacheKey = typename Cache::Key;\n\n// cache config\nCacheConfig config;\nconfig\n  .setCacheSize(1024 * 1024)\n  .setCacheName("test")\n  .enableCachePersistence("cacheDir")\n  .usePosixForShm()\n  .validate();\n\n// init cache\nstd::unique_ptr<Cache> cache;\ntry {\n  cache = std::make_unique<Cache>(Cache::SharedMemAttach, config);\n} catch (const std::exception& e) {\n  cache = std::make_unique<Cache>(Cache::SharedMemNew, config);\n}\n\n// ... use cache ...\n\n// shutdown cache\ncache->shutDown();\n\n// persist cache\npersistence::PersistenceManager manager(config);\ntry {\n  FileWriter writer("/nas/file/path");\n  manager.saveCache(writer);\n} catch (const std::exception& e) {\n  std::cerr << "Couldn\'t persist cache: " << e.what() << std::endl;\n}\n')),(0,i.mdx)("h3",{id:"restore-cache"},"Restore Cache"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-cpp"},'#include "cachelib/persistence/PersistenceManager.h"\nusing namespace facebook::cachelib;\n\nusing Cache = cachelib::LruAllocator;\nusing CacheConfig = typename Cache::Config;\nusing CacheKey = typename Cache::Key;\n\n// cache config\nCacheConfig config;\nconfig\n  .setCacheSize(1024 * 1024)\n  .setCacheName("test")\n  .enableCachePersistence("cacheDir")\n  .usePosixForShm()\n  .validate();\n\n// restore cache\npersistence::PersistenceManager manager(config);\ntry {\n  FileReader reader("/nas/file/path");\n  manager.restoreCache(reader);\n} catch (const std::exception& e) {\n  std::cerr << "Couldn\'t restore cache: " << e.what() << std::endl;\n}\n\n// try to attach cache\nstd::unique_ptr<Cache> cache;\ntry {\n  cache = std::make_unique<Cache>(Cache::SharedMemAttach, config);\n} catch (const std::exception& e) {\n  cache = std::make_unique<Cache>(Cache::SharedMemNew, config);\n}\n\n// ... use cache ...\n\n// shutdown cache\ncache->shutDown();\n')))}u.isMDXComponent=!0}}]);