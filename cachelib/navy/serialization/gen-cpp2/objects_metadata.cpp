/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <thrift/lib/cpp2/gen/module_metadata_cpp.h>
#include "/h/bsberg/CacheLib2/cachelib/navy/serialization/gen-cpp2/objects_metadata.h"

namespace apache {
namespace thrift {
namespace detail {
namespace md {
using ThriftMetadata = ::apache::thrift::metadata::ThriftMetadata;
using ThriftPrimitiveType = ::apache::thrift::metadata::ThriftPrimitiveType;
using ThriftType = ::apache::thrift::metadata::ThriftType;
using ThriftService = ::apache::thrift::metadata::ThriftService;
using ThriftServiceContext = ::apache::thrift::metadata::ThriftServiceContext;
using ThriftFunctionGenerator = void (*)(ThriftMetadata&, ThriftService&);


void StructMetadata<::facebook::cachelib::navy::serialization::IndexEntry>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs.emplace("objects.IndexEntry", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_IndexEntry = res.first->second;
  objects_IndexEntry.name = "objects.IndexEntry";
  objects_IndexEntry.is_union = false;
  static const std::tuple<int32_t, const char*, bool, std::unique_ptr<MetadataTypeInterface>>
  objects_IndexEntry_fields[] = {
    std::make_tuple(1, "key", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
    std::make_tuple(2, "value", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
  };
  for (const auto& f : objects_IndexEntry_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id = std::get<0>(f);
    field.name = std::get<1>(f);
    field.is_optional = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(field.type, metadata);
    objects_IndexEntry.fields.push_back(std::move(field));
  }
}
void StructMetadata<::facebook::cachelib::navy::serialization::IndexBucket>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs.emplace("objects.IndexBucket", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_IndexBucket = res.first->second;
  objects_IndexBucket.name = "objects.IndexBucket";
  objects_IndexBucket.is_union = false;
  static const std::tuple<int32_t, const char*, bool, std::unique_ptr<MetadataTypeInterface>>
  objects_IndexBucket_fields[] = {
    std::make_tuple(1, "bucketId", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
    std::make_tuple(2, "entries", false, std::make_unique<List>(std::make_unique<Struct< ::facebook::cachelib::navy::serialization::IndexEntry>>("objects.IndexEntry"))),
  };
  for (const auto& f : objects_IndexBucket_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id = std::get<0>(f);
    field.name = std::get<1>(f);
    field.is_optional = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(field.type, metadata);
    objects_IndexBucket.fields.push_back(std::move(field));
  }
}
void StructMetadata<::facebook::cachelib::navy::serialization::Region>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs.emplace("objects.Region", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_Region = res.first->second;
  objects_Region.name = "objects.Region";
  objects_Region.is_union = false;
  static const std::tuple<int32_t, const char*, bool, std::unique_ptr<MetadataTypeInterface>>
  objects_Region_fields[] = {
    std::make_tuple(1, "regionId", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
    std::make_tuple(2, "lastEntryEndOffset", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
    std::make_tuple(3, "classId", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
    std::make_tuple(4, "numItems", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
    std::make_tuple(5, "pinned", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE)),
  };
  for (const auto& f : objects_Region_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id = std::get<0>(f);
    field.name = std::get<1>(f);
    field.is_optional = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(field.type, metadata);
    objects_Region.fields.push_back(std::move(field));
  }
}
void StructMetadata<::facebook::cachelib::navy::serialization::RegionData>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs.emplace("objects.RegionData", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_RegionData = res.first->second;
  objects_RegionData.name = "objects.RegionData";
  objects_RegionData.is_union = false;
  static const std::tuple<int32_t, const char*, bool, std::unique_ptr<MetadataTypeInterface>>
  objects_RegionData_fields[] = {
    std::make_tuple(1, "regions", false, std::make_unique<List>(std::make_unique<Struct< ::facebook::cachelib::navy::serialization::Region>>("objects.Region"))),
    std::make_tuple(2, "regionSize", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
  };
  for (const auto& f : objects_RegionData_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id = std::get<0>(f);
    field.name = std::get<1>(f);
    field.is_optional = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(field.type, metadata);
    objects_RegionData.fields.push_back(std::move(field));
  }
}
void StructMetadata<::facebook::cachelib::navy::serialization::AccessStats>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs.emplace("objects.AccessStats", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_AccessStats = res.first->second;
  objects_AccessStats.name = "objects.AccessStats";
  objects_AccessStats.is_union = false;
  static const std::tuple<int32_t, const char*, bool, std::unique_ptr<MetadataTypeInterface>>
  objects_AccessStats_fields[] = {
    std::make_tuple(1, "totalHits", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE)),
    std::make_tuple(2, "currHits", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE)),
    std::make_tuple(3, "numReinsertions", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE)),
  };
  for (const auto& f : objects_AccessStats_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id = std::get<0>(f);
    field.name = std::get<1>(f);
    field.is_optional = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(field.type, metadata);
    objects_AccessStats.fields.push_back(std::move(field));
  }
}
void StructMetadata<::facebook::cachelib::navy::serialization::AccessTracker>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs.emplace("objects.AccessTracker", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_AccessTracker = res.first->second;
  objects_AccessTracker.name = "objects.AccessTracker";
  objects_AccessTracker.is_union = false;
  static const std::tuple<int32_t, const char*, bool, std::unique_ptr<MetadataTypeInterface>>
  objects_AccessTracker_fields[] = {
    std::make_tuple(1, "data", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::make_unique<Struct< ::facebook::cachelib::navy::serialization::AccessStats>>("objects.AccessStats"))),
  };
  for (const auto& f : objects_AccessTracker_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id = std::get<0>(f);
    field.name = std::get<1>(f);
    field.is_optional = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(field.type, metadata);
    objects_AccessTracker.fields.push_back(std::move(field));
  }
}
void StructMetadata<::facebook::cachelib::navy::serialization::BlockCacheConfig>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs.emplace("objects.BlockCacheConfig", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_BlockCacheConfig = res.first->second;
  objects_BlockCacheConfig.name = "objects.BlockCacheConfig";
  objects_BlockCacheConfig.is_union = false;
  static const std::tuple<int32_t, const char*, bool, std::unique_ptr<MetadataTypeInterface>>
  objects_BlockCacheConfig_fields[] = {
    std::make_tuple(1, "version", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(2, "cacheBaseOffset", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(3, "cacheSize", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(4, "blockSize", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
    std::make_tuple(5, "sizeClasses", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE))),
    std::make_tuple(6, "checksum", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE)),
    std::make_tuple(7, "sizeDist", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE))),
    std::make_tuple(8, "holeCount", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(9, "holeSizeTotal", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(10, "reinsertionPolicyEnabled", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE)),
  };
  for (const auto& f : objects_BlockCacheConfig_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id = std::get<0>(f);
    field.name = std::get<1>(f);
    field.is_optional = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(field.type, metadata);
    objects_BlockCacheConfig.fields.push_back(std::move(field));
  }
}
void StructMetadata<::facebook::cachelib::navy::serialization::BigHashPersistentData>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs.emplace("objects.BigHashPersistentData", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_BigHashPersistentData = res.first->second;
  objects_BigHashPersistentData.name = "objects.BigHashPersistentData";
  objects_BigHashPersistentData.is_union = false;
  static const std::tuple<int32_t, const char*, bool, std::unique_ptr<MetadataTypeInterface>>
  objects_BigHashPersistentData_fields[] = {
    std::make_tuple(1, "version", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
    std::make_tuple(2, "generationTime", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(3, "itemCount", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(4, "bucketSize", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(5, "cacheBaseOffset", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(6, "numBuckets", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(7, "sizeDist", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE))),
  };
  for (const auto& f : objects_BigHashPersistentData_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id = std::get<0>(f);
    field.name = std::get<1>(f);
    field.is_optional = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(field.type, metadata);
    objects_BigHashPersistentData.fields.push_back(std::move(field));
  }
}
void StructMetadata<::facebook::cachelib::navy::serialization::BloomFilterPersistentData>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs.emplace("objects.BloomFilterPersistentData", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_BloomFilterPersistentData = res.first->second;
  objects_BloomFilterPersistentData.name = "objects.BloomFilterPersistentData";
  objects_BloomFilterPersistentData.is_union = false;
  static const std::tuple<int32_t, const char*, bool, std::unique_ptr<MetadataTypeInterface>>
  objects_BloomFilterPersistentData_fields[] = {
    std::make_tuple(1, "numFilters", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
    std::make_tuple(2, "hashTableBitSize", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(3, "filterByteSize", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)),
    std::make_tuple(4, "fragmentSize", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)),
    std::make_tuple(5, "seeds", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE))),
  };
  for (const auto& f : objects_BloomFilterPersistentData_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id = std::get<0>(f);
    field.name = std::get<1>(f);
    field.is_optional = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(field.type, metadata);
    objects_BloomFilterPersistentData.fields.push_back(std::move(field));
  }
}

} // namespace md
} // namespace detail
} // namespace thrift
} // namespace apache
