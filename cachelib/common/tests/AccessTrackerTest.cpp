// Copyright 2004-present Facebook. All Rights Reserved.

#include <gtest/gtest.h>

#include <folly/Random.h>

#include "cachelib/common/AccessTracker.h"

namespace facebook {
namespace cachelib {
using namespace ::testing;

class AccessTrackerTest : public ::testing::TestWithParam<bool> {
 protected:
  // Assert two feature vectors generated by tracker are equal.
  void assertVecEq(const std::vector<double>& actual,
                   const std::vector<double>& expected) {
    ASSERT_EQ(actual.size(), expected.size());
    for (size_t i = 0; i < actual.size(); i++) {
      ASSERT_EQ(actual[i], sanitizeCount(expected[i]));
    }
  }

  // Convert count to BF result.
  double sanitizeCount(double count) {
    return GetParam() ? count : (count > 0 ? 1 : 0);
  }

 protected:
  void advanceTicks() { ticks++; }

  // Start from the first tick of the bucket so that test cases
  // are not disturbed by randomization.
  void initializeTicks(size_t ticksPerBucket) {
    ticks = initialTicks - initialTicks % ticksPerBucket;
  }

  AccessTracker::TickerFct getCurrentTick{[&] { return ticks; }};

 private:
  // Random initial tick number.
  size_t initialTicks{folly::Random::rand32()};

  // Current tick number.
  size_t ticks;
};

INSTANTIATE_TEST_CASE_P(AccessTrackerTest, AccessTrackerTest, testing::Bool());

TEST_P(AccessTrackerTest, simpleTestCase) {
  auto config = AccessTracker::Config();
  config.numBuckets = 3;
  config.useCounts = GetParam();
  // Moves to a new bucket every two accesses.
  config.numTicksPerBucket = 2;
  config.getCurrentTick = std::move(getCurrentTick);
  initializeTicks(config.numTicksPerBucket);
  auto tracker = AccessTracker(std::move(config));

  // The count is taken after the access tracking vector is returned.
  // After each assertion, the line below shows the status of the buckest, in
  // natural index order. The expected output order is rotated to start from
  // the most recent admission.
  folly::StringPiece key0 = "key0";
  // Bucket 0.
  // key0: {1, 0, 0}
  assertVecEq(tracker.recordAndPopulateAccessFeatures(key0), {1, 0, 0});
  advanceTicks();
  // key0: {2, 0, 0}
  assertVecEq(tracker.recordAndPopulateAccessFeatures(key0), {2, 0, 0});
  advanceTicks();

  // Bucket 1.
  folly::StringPiece key1 = "key1";
  // different keys are not affected.
  // key1: {0, 1, 0}
  assertVecEq(tracker.recordAndPopulateAccessFeatures(key1), {1, 0, 0});
  advanceTicks();

  // key1: {0, 2, 0}
  assertVecEq(tracker.recordAndPopulateAccessFeatures(key1), {2, 0, 0});
  advanceTicks();

  // Bucket 2.
  // key0: {2, 0, 1}
  assertVecEq(tracker.recordAndPopulateAccessFeatures(key0), {1, 0, 2});
  advanceTicks();
  // key0: {2, 0, 2}
  assertVecEq(tracker.recordAndPopulateAccessFeatures(key0), {2, 0, 2});
  advanceTicks();

  // Bucket 3.
  // Rotated, first 0 is discarded.
  assertVecEq(tracker.recordAndPopulateAccessFeatures(key0), {1, 2, 0});
  advanceTicks();
  // key0: {2, 0, 2, 1}
  assertVecEq(tracker.recordAndPopulateAccessFeatures(key0), {2, 2, 0});
  advanceTicks();
  // key0: {2, 0, 2, 2}

  // Bucket 4.
  // counts in bucket 1 was cleared and reset at last record.
  assertVecEq(tracker.recordAndPopulateAccessFeatures(key0), {1, 2, 2});
  advanceTicks();
  // key0: {2, 0, 2, 2, 1}
  // The other key's buckets were moved forward as well.
  assertVecEq(tracker.recordAndPopulateAccessFeatures(key1), {1, 0, 0});
  // key1: {0, 2, 0, 0, 1}
}

} // namespace cachelib
} // namespace facebook
