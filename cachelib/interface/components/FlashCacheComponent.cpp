/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "cachelib/interface/components/FlashCacheComponent.h"

#include "cachelib/common/Time.h"
#include "cachelib/interface/utils/CoroFiberAdapter.h"

using namespace facebook::cachelib::navy;

namespace facebook::cachelib::interface {

/**
 * In-memory buffer for data cached in flash. Reference counting via
 * RegionDescriptors is used to ensure the backing Region is still resident &
 * valid while working on this cache item. The buffer's layout is:
 *
 *   ---------------------------------------------------------------------------
 *   | creation & expiry time ||  value  || (empty) |  key  | entry descriptor |
 *   ---------------------------------------------------------------------------
 */
class FlashCacheItem : public CacheItem {
 public:
  using EntryDesc = BlockCache::EntryDesc;

  static constexpr size_t kMetadataSize = 2 * sizeof(uint32_t);

  // Allocation constructor
  // NOTE: valueSize *must* include space for creation & expiration time
  FlashCacheItem(const HashedKey& hashedKey,
                 uint32_t valueSize,
                 FlashCacheComponent::AllocData&& allocation,
                 const uint32_t creationTime,
                 const uint32_t ttlSecs)
      : desc_(std::move(std::get<0>(allocation))),
        relAddr_(std::move(std::get<2>(allocation))),
        buffer_(std::get<1>(allocation)) {
    XDCHECK_GE(valueSize, 2 * sizeof(uint32_t))
        << "valueSize doesn't include space for metadata";
    BlockCache::writeEntryDescAndKey(buffer_, hashedKey, valueSize);
    uint32_t* metadata = reinterpret_cast<uint32_t*>(buffer_.data());
    metadata[0] = creationTime;
    metadata[1] = ttlSecs > 0 ? creationTime + ttlSecs : 0;
  }

  // Find constructor
  // NOTE: there's no reason to hold on to the descriptor or relative address
  // generated by find(), we only need the buffer
  explicit FlashCacheItem(BlockCache::LookupData&& ld)
      : buffer_(std::move(ld.buffer_)) {}

  // FindToWrite constructor
  FlashCacheItem(FlashCacheComponent::AllocData&& allocation,
                 Buffer&& existingData)
      : desc_(std::move(std::get<0>(allocation))),
        relAddr_(std::move(std::get<2>(allocation))),
        buffer_(std::move(existingData)) {
    XDCHECK_EQ(buffer_.size(), std::get<1>(allocation))
        << "New allocation has a different size than existing data";
  }

  RegionDescriptor& getRegionDescriptor() noexcept { return desc_; }
  RelAddress& getRelAddress() noexcept { return relAddr_; }
  Buffer& getBuffer() noexcept { return buffer_; }
  EntryDesc* getEntryDescriptor() const noexcept {
    auto entryEnd = const_cast<uint8_t*>(buffer_.data()) + buffer_.size();
    return reinterpret_cast<EntryDesc*>(entryEnd - sizeof(EntryDesc));
  }

  // ------------------------------ Interface ------------------------------ //

  uint32_t getCreationTime() const noexcept override {
    return reinterpret_cast<const uint32_t*>(buffer_.data())[0];
  }
  uint32_t getExpiryTime() const noexcept override {
    return reinterpret_cast<const uint32_t*>(buffer_.data())[1];
  }
  // Ref-counting for FlashCache is different than RAMCache - multiple
  // RAMCacheItems all refer to a single cache item in memory whereas each
  // FlashCacheItem is separate (even if it references the same cache item in
  // Region memory).
  //
  // The only thing we care about is Region refcounting via RegionDescriptor. We
  // don't need to increment on create (creating the RegionDescriptor does that)
  // and we should always release the cache item to release the descriptor.
  void incrementRefCount() noexcept override {}
  bool decrementRefCount() noexcept override {
    // get cache to release the descriptor (need access to RegionManager)
    return true;
  }
  Key getKey() const noexcept override {
    auto* desc = getEntryDescriptor();
    return Key{reinterpret_cast<const char*>(desc) - desc->keySize,
               desc->keySize};
  }
  void* getMemory() const noexcept override {
    return const_cast<uint8_t*>(buffer_.data() + kMetadataSize);
  }
  uint32_t getMemorySize() const noexcept override {
    return getEntryDescriptor()->valueSize - kMetadataSize;
  }
  uint32_t getTotalSize() const noexcept override { return buffer_.size(); }

 private:
  // Used for region lifecycle management & indexing
  RegionDescriptor desc_;
  RelAddress relAddr_;
  // Data is buffered in RAM
  Buffer buffer_;
};

/* static */ Result<FlashCacheComponent> FlashCacheComponent::create(
    std::string name, navy::BlockCache::Config&& config) noexcept {
  try {
    return FlashCacheComponent(std::move(name), std::move(config));
  } catch (const std::invalid_argument& ia) {
    return makeError(Error::Code::INVALID_CONFIG, ia.what());
  }
}

template <typename FuncT, typename ReturnT, typename CleanupFuncT>
folly::coro::Task<ReturnT> FlashCacheComponent::onWorkerThread(
    FuncT&& func, CleanupFuncT&& cleanup) {
  XDCHECK(!cache_->regionManager_.isOnWorker())
      << "Calling public APIs from a worker thread is unsupported";
  co_return co_await utils::onWorkerThread(
      cache_->regionManager_.getNextWorker(),
      std::forward<FuncT>(func),
      std::forward<CleanupFuncT>(cleanup));
}

const std::string& FlashCacheComponent::getName() const noexcept {
  return name_;
}

folly::coro::Task<Result<FlashCacheComponent::AllocData>>
FlashCacheComponent::allocateImpl(const HashedKey& key, uint32_t valueSize) {
  auto ret = co_await onWorkerThread(
      [=, this]() { return cache_->allocateForInsert(key, valueSize); },
      [this](auto&& result) {
        if (result.hasValue()) {
          // Successfully allocated Region memory but coroutine was cancelled -
          // close the descriptor to release refcount on the Region
          auto& [desc, slotSize, _] = result.value();
          cache_->addHole(slotSize);
          cache_->regionManager_.close(std::move(desc));
        }
      });
  if (ret.hasValue()) {
    co_return std::move(ret).value();
  } else {
    co_return makeError(Error::Code::ALLOCATE_FAILED,
                        "could not allocate space in a region");
  }
}

folly::coro::Task<Result<AllocatedHandle>> FlashCacheComponent::allocate(
    Key key, uint32_t size, uint32_t creationTime, uint32_t ttlSecs) {
  if (key.empty()) {
    co_return makeError(Error::Code::INVALID_ARGUMENTS, "empty key");
  }

  HashedKey hashedKey(key);
  uint32_t valueSize = size + FlashCacheItem::kMetadataSize;
  co_return (co_await allocateImpl(hashedKey, valueSize)).then([&](auto value) {
    // NOTE: we can't checksum until the user has finished writing their data,
    // defer until they call insert()
    auto* item = new FlashCacheItem(hashedKey, valueSize, std::move(value),
                                    creationTime, ttlSecs);
    return AllocatedHandle(*this, *item);
  });
}

folly::coro::Task<UnitResult> FlashCacheComponent::insertImpl(
    AllocatedHandle&& handle, bool allowReplace) {
  if (!handle) {
    co_return makeError(Error::Code::INVALID_ARGUMENTS,
                        "empty AllocatedHandle");
  }

  if (writeBackImpl(*handle, allowReplace)) {
    setInserted(handle, true);
    auto _ = std::move(handle);
    co_return folly::unit;
  } else {
    // NOTE: do hole accounting in release()
    co_return makeError(Error::Code::ALREADY_INSERTED, "key already inserted");
  }
}

folly::coro::Task<UnitResult> FlashCacheComponent::insert(
    AllocatedHandle&& handle) {
  co_return co_await insertImpl(std::move(handle), /* allowReplace */ false);
}

folly::coro::Task<Result<std::optional<AllocatedHandle>>>
FlashCacheComponent::insertOrReplace(AllocatedHandle&& handle) {
  auto inserted =
      co_await insertImpl(std::move(handle), /* allowReplace */ true);
  XDCHECK(inserted) << "insertOrReplace should never fail";
  // NOTE: returning the old data requires a flash read, don't expose for now
  co_return std::move(inserted).then([](auto&&) {
    return Result<std::optional<AllocatedHandle>>(std::nullopt);
  });
}

folly::coro::Task<Result<std::optional<ReadHandle>>> FlashCacheComponent::find(
    Key key) {
  auto res = co_await onWorkerThread(
      [this, hashedKey = HashedKey(key)]()
          -> folly::Expected<BlockCache::LookupData, navy::Status> {
        auto ld = cache_->lookupInternal(hashedKey);
        if (ld.status_ == Status::Retry) {
          XDCHECK(!ld.desc_.isReady())
              << "should not have a ready descriptor for retry status";
          return folly::makeUnexpected(ld.status_);
        }
        return ld;
      },
      [this](auto&& res) {
        if (res.hasValue() && res->desc_.isReady()) {
          cache_->regionManager_.close(std::move(res->desc_));
        }
      });
  // Retry is handled by onWorkerThread, we should always have a value here
  XDCHECK(res.hasValue()) << "should always get value from lookupInternal()";
  auto& ld = res.value();

  // No need to hold on to the descriptor - we can't write to it (no write back)
  // and remove(handle) only uses the buffer for the destructor callback
  if (ld.desc_.isReady()) {
    cache_->regionManager_.close(std::move(ld.desc_));
  }

  switch (ld.status_) {
  case Status::Ok: {
    auto expiryTime = reinterpret_cast<const uint32_t*>(ld.buffer_.data())[1];
    if (util::isExpired(expiryTime)) {
      co_return std::nullopt;
    }
    co_return ReadHandle(*this, *(new FlashCacheItem(std::move(ld))));
  }
  case Status::NotFound:
    co_return std::nullopt;
  default:
    co_return makeError(Error::Code::FIND_FAILED,
                        "flash device or checksum error");
  }
}

folly::coro::Task<Result<std::optional<WriteHandle>>>
FlashCacheComponent::findToWrite(Key key) {
  uint64_t keyHash;
  uint32_t valueSize;
  Buffer buf;
  {
    auto findResult = co_await find(key);
    if (findResult.hasError()) {
      co_return folly::makeUnexpected(std::move(findResult).error());
    } else if (!findResult->has_value()) {
      co_return std::nullopt;
    }

    auto* fccItem = reinterpret_cast<FlashCacheItem*>(
        const_cast<CacheItem*>(findResult.value()->get()));
    const auto* entryDesc = fccItem->getEntryDescriptor();
    keyHash = entryDesc->keyHash;
    valueSize = entryDesc->valueSize;
    buf = std::move(fccItem->getBuffer());
  }

  auto hashedKey = HashedKey::precomputed(key, keyHash);
  co_return (co_await allocateImpl(hashedKey, valueSize)).then([&](auto value) {
    auto* newItem = new FlashCacheItem(std::move(value), std::move(buf));
    return WriteHandle(*this, *newItem);
  });
}

folly::coro::Task<Result<bool>> FlashCacheComponent::remove(Key key) {
  auto res = co_await onWorkerThread(
      [this,
       hashedKey = HashedKey(key)]() -> folly::Expected<bool, navy::Status> {
        auto innerResult = cache_->remove(hashedKey);
        switch (innerResult) {
        case navy::Status::Ok:
          return true;
        case navy::Status::NotFound:
          return false;
        default:
          return folly::makeUnexpected(innerResult);
        }
      }
      // No cleanup needed - it doesn't matter if we removed the item or not if
      // the operation was cancelled (operation is "indeterminate")
  );
  if (res.hasValue()) {
    co_return res.value();
  } else {
    co_return makeError(Error::Code::REMOVE_FAILED,
                        "could not remove item from flash");
  }
}

folly::coro::Task<UnitResult> FlashCacheComponent::remove(ReadHandle&& handle) {
  if (!handle) {
    co_return makeError(Error::Code::INVALID_ARGUMENTS, "empty ReadHandle");
  }

  cache_->removeCount_.inc();
  auto& fccItem =
      reinterpret_cast<FlashCacheItem&>(const_cast<CacheItem&>(*handle));
  auto hashedKey = HashedKey::precomputed(
      fccItem.getKey(), fccItem.getEntryDescriptor()->keyHash);
  auto status = cache_->removeImpl(hashedKey, fccItem.getBuffer());
  XDCHECK(status == navy::Status::Ok || status == navy::Status::NotFound);
  auto _ = std::move(handle);
  co_return folly::unit;
}

FlashCacheComponent::FlashCacheComponent(std::string&& name,
                                         navy::BlockCache::Config&& config)
    : name_(std::move(name)),
      cache_(std::make_unique<navy::BlockCache>(std::move(config))) {}

bool FlashCacheComponent::writeBackImpl(CacheItem& item, bool allowReplace) {
  auto& fccItem = reinterpret_cast<FlashCacheItem&>(item);
  auto* desc = fccItem.getEntryDescriptor();
  auto logicalSizeWritten = desc->keySize + desc->valueSize;
  auto totalSize = fccItem.getTotalSize();
  auto keyHash = desc->keyHash;

  // NOTE: we don't need to run this on a worker thread because everything here
  // is synchronous - only allocation is async

  if (cache_->checksumData_) {
    desc->cs = checksum(fccItem.getBuffer().view().slice(0, desc->valueSize));
  }
  cache_->regionManager_.write(fccItem.getRelAddress(),
                               std::move(fccItem.getBuffer()));
  cache_->logicalWrittenCount_.add(logicalSizeWritten);
  return cache_->updateIndex(keyHash, totalSize, fccItem.getRelAddress(),
                             allowReplace);
}

UnitResult FlashCacheComponent::writeBack(CacheItem& item) {
  auto inserted = writeBackImpl(item, /* allowReplace */ true);
  XDCHECK(inserted) << "writeBack should never fail";
  return folly::unit;
}

folly::coro::Task<void> FlashCacheComponent::release(CacheItem& item,
                                                     bool inserted) {
  auto& fccItem = reinterpret_cast<FlashCacheItem&>(item);
  if (!inserted) {
    cache_->addHole(fccItem.getTotalSize());
  }
  if (fccItem.getRegionDescriptor().isReady()) {
    cache_->regionManager_.close(std::move(fccItem.getRegionDescriptor()));
  }
  delete &item;
  co_return;
}

} // namespace facebook::cachelib::interface
